这个章节解释了使用散列函数去保护密码背后的原因，以及怎样有效的做到这一点。

为什么我要对我的应用程序用户提供的密码进行散列？
为什么常见的散列函数如 md5() 和 sha1() 不适用于密码？
如果常见的散列函数不再合适，那么我应该如何散列我的密码？
什么是 salt ?
我应该如何存储我的 salt ？

为什么我要对我的应用程序用户提供的密码进行散列？
    当设计任何会接受用户密码的应用程序时，密码散列是必须进行的、最基础的安全考虑之一。没有散列的话，如果数据库被泄露，那么存储在应用程序数据库
    中的密码就会被盗取，然后该密码不仅会被立刻使用去破解你的应用程序，还会去泄露你的用户在其他服务上的账户，如果他们没有使用唯一的密码的话。

    通过在把用户密码存储到数据库之前先对其应用一个散列算法，会使任何攻击者都不可能确定原始的密码，而且在将来仍然可以把结果散列与原始密码进行
    比较。

    然而，需要注意的是，散列密码只能保护密码在数据存储中不被泄露，但并不一定能保护它们不被注入到应用程序本身的恶意代码所拦截。

为什么常见的散列函数如 md5() 和 sha1() 不适用于密码？
    散列算法如 MD5、SHA1 和 SHA256 被设计得非常快速和高效。随着现代技术和计算机设备的发展，为了确定原始的输入，对这些算法的输出进行
    “暴力破解”已经变得微不足道。

    由于一台现代的计算机可以快速地“反转”这些散列算法，许多安全专家强烈建议反对使用它们进行密码散列。

如果常见的散列函数不再合适，那么我应该如何散列我的密码？
    在进行密码散列时，最重要的两个考虑事项是计算开销和 salt 。散列算法的计算开销越大，暴力破解所需的时间就越长。

    PHP 5.5 提供了 一套原生的密码散列 API ，它可以用一种安全的方式安全地处理 散列计算 和 密码验证 。对于 PHP 5.3.7 和以后版本，也有一个
    纯 PHP 的兼容库 可用。

    在 PHP 5.3 及以后版本中，另外一种选择是 crypt() 函数，它支持许多散列算法。当使用这个函数时，可以保证选择的算法是可用的，因为 PHP 包含
    了每种受支持的算法的原生实现，假如你的系统不支持某一种或某几种算法的话。

    当散列密码时，建议使用的算法是 Blowfish，这也是密码散列 API 默认使用的算法，因为它比 MD5 或 SHA1 的计算开销大得多，而且还是可伸缩的。

    注意，如果你正在使用 crypt() 去验证一个密码，你需要注意应使用一个恒定时间的字符串比较来防止计时攻击。PHP 的 == 和 === 操作符和
    strcmp() 都不会执行恒定时间的字符串比较。由于 password_verify() 将会为你完成这项任务，所以强烈建议你尽可能使用 原生的密码散列 API 。

什么是 salt ?
    加密 salt 是一个在散列处理过程中被应用的数据，为了消除在预先计算好的散列对及其输入的列表中查找输出的可能性，也被称为彩虹表。

    用更简单地话来说，salt 就是使散列值更难被破解的一点额外数据。网上有许多服务会提供大量的预先计算好的散列以及其原始输入的列表。由于使用了
    一个 salt，因此很难或不可能在这些列表中找到结果散列。

    如果某个人没有提供一个 salt，那么 password_hash() 将会创建一个随机的 salt，这通常是最简单、最安全的方法。

我应该如何存储我的 salt ？
    当使用 password_hash() 或 crypt() 时，返回值会包含 salt，作为生成的散列的一部分。这个返回值应该逐字的存储在数据库中，因为它包含与所
    使用的散列函数有关的信息，并且在进行密码验证时可以直接传给 password_verify() 或 crypt() 。

    下图显示了从 crypt() 或 password_hash() 返回的值的格式。正如你能看到的，它们是自包含的，带有将来进行密码验证时需要的所有与算法和
    salt 相关的信息。
