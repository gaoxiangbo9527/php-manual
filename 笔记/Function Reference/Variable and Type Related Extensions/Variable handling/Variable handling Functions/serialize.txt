描述
    serialize ( mixed $value ) : string

    生成某个值的一种可存储的表示形式（的字符串）。
    这对于存储或传递 PHP 值很有用，而且还不会丢失它们的类型和结构。
    为了再次将已序列化的字符串转换为 PHP 值，使用 unserialize() 。

参数
    value
        将要序列化的值。
        serialize() 可以处理有所的类型，除了 资源类型 和 一些对象（参阅下文的注意）。

        你甚至可以序列化包含了到自身的引用的数组。
        你正在序列化的对象或者数组中的循环引用也会被存储，其它的任何引用都会丢失。

        当序列化对象时，在序列化之前 PHP 会尝试调用成员方法 __serialize() 或 __sleep()，这允许对象在序列化之前的最后一刻进行清理。
        相应的，当使用 unserialize() 函数恢复对象时，会调用 __unserialize() 或 __wakeup() 成员方法。

        注意：
            对象的私有成员会在私有成员名前面加上类名作为前缀；
            对象的保护成员会在保护成员名前面加上 * 作为前缀；
            这些前缀值的两侧都会有一个空字节，即 \0。

返回值
    返回一个包含 value 的字节流表示形式的字符串，从而可以保存在任何地方。

    注意这是一个可能会包含空字节的二进制字符串，所以必须按照这种方式去存储和处理，例如 serialize() 函数的返回值通常应被存储到一个数据库的
    BLOB 类型的字段中，而不是一个 char 或 text 类型的字段中。

注意事项
    注意
        注意，很多内置的 PHP 对象不能被序列化，然而实现了 Serialize 接口或魔术方法 __serialize()/__unserialize() 或
        __sleep()/__wakeup() 的对象却是具备被序列化能力的。如果一个内置类不满足上述这些需求中的任何一个，则其序列化的结果是不可信的。
        个人测试：好多内置类就算没有满足这三个需求中的任何一个也可以序列化，但是就像上面说的，序列化的结果不可信。

        由于历史原因，上述规则有一些列外；有一些内置的对象不需要实现 Serialize 接口或暴露魔术方法就可以被序列化，尤其是 PHP 5.2.0 以前的
        ArrayObject 。

    警告
        当 serialize() 序列化对象时，对于在某个命名空间下的类，为了最大的兼容性，类名中不会包含开头的反斜线。
