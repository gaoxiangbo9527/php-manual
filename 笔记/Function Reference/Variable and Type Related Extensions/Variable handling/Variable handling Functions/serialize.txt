描述
    serialize ( mixed $value ) : string

    生成某个值的一种可存储的形式（的字符串）。
    这对于存储或传递 PHP 值很有用，而且还不会丢失它们的类型和结构。
    为了再次将序列化后的字符串转换为PHP值，使用 unserialize() 。
参数
    value
        将要序列化的值。
        serialize() 可以处理有所的类型，除了资源类型和一些对象（参阅下文的注意）。
        你甚至可以序列化包含了到自身的引用的数组。
        你正在序列化的对象或者数组中的循环引用也会被序列化，其它的任何引用都会丢失。
        （个人补充）上面的特殊情况其实很好理解，引用在反序列化时很难解析回来，资源和一部分对象也差不多是这样。

        当序列化对象时，在序列化之前 PHP 会尝试调用成员方法 __sleep()，这允许对象在序列化之前的最后一刻进行清理。
        相应的，当使用 unserialize() 函数恢复对象时，会调用 __wakeup() 成员方法。

        注意：
            对象的私有成员会在私有成员名前面加上类名作为前缀；
            对象的保护成员会在保护成员名前面加上 * 作为前缀；
            这些前缀值的两侧都会有一个空字节，即 \0。
返回值
    返回包含 value 的字节流形式的字符串，从而可以保存在任何地方。

    注意这是一个可能会包含空字节的二进制字符串，所以必须按照这种形式去处理，例如 serialize() 函数的返回值通常应被存储到一个数据库的 BLOB 类型的
    字段中，而不是一个 char 或 text 类型的字段中。
注意事项
    注意
        注意，很多内置的 PHP 对象不能被序列化，然而实现了 Serialize 接口或 __sleep() 和 __wakeup() 魔术方法的对象却是具备被序列化能力的。
        如果一个内置类不满足上述两个条件中的任何一个，则其序列化的结果是不可信的。
        （个人补充：对于用户空间的对象，好像不需要强制实现 Serialize 接口或 __sleep() 和 __wakeup() 魔术方法 就可以被序列化。）

        由于历史原因，上述规则有一些列外；有一些内置的对象不需要实现 Serialize 接口或暴露魔术方法就可以被序列化，尤其是 PHP 5.2.0 以前的
        ArrayObject 。
    警告
        当序列化对象时，对于在某个命名空间下的类，为了最大的兼容性，类名中不会包含开头的反斜线。
