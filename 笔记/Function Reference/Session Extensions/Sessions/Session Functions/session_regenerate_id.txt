个人总结
    从原理上来说，这个函数已经不能用了，所以不要用了。为什么不能用，见下方的描述。
    不过我们可以在不用这个函数的情况下，自己解决这个问题，去实现切换会话 id 的目的。具体的实现示例代码，见示例 2。

    假设有对同一个页面的 2 个并发请求，它们的会话 id 都是 A，我们要在该页面中使用 session_regenerate_id() 更换会话 id。

    如果使用 session_regenerate_id()
        如果 $delete_old_session 为 TRUE
            在第 1 个请求执行完成后，新的会话 id 会被建立，假设为 B，会话 A 的文件会被删除。此时对于第 2 个请求来说，它现在的会话 id A 是
            找不到对应的会话文件的，此时 PHP 会根据 session.use_strict_mode 的值去做决定；如果开启了严格模式，那么第 2 个请求会建立新
            的会话 C，完全忽略第 1 个请求的会话，相当于会话丢失，如果没开启严格模式，那么第 2 个请求会重新建立会话 A，但此时第 1 个请求所
            保存的会话数据早就没了，还是相当于会话丢失；之后还会去建立新的会话 id D。第 3 个请求的情况是一样的。

            总之，会发生会话丢失，还会创建一堆的无用的新的会话。
        如果 $delete_old_session 为 FALSE
            在第 1 个请求执行完成后，新的会话 id 会被建立，假设为 B。此时对于第 2 个请求来说，它现在的会话 id A 还是可以找到对应的会话文
            件的，所以第 2 个请求会读取到和第 1 个请求一样的会话数据，而不会读取到第 1 个请求所保存的会话 B 的数据，这算是数据不一致，而且
            第 2 个请求最后还会创建新的会话 id，假设为 C。

            总之，某个请求是无法读取前一个请求所保存的会话数据，这是数据不一致；另外，每个请求都会创建自己的新的会话，也就会创建一堆无用的新
            的会话。

    综上所述，不管 $delete_old_session 参数如何，session_regenerate_id() 函数都会有问题。所以可以得出结论，想要实现切换会话 id，靠
    session_regenerate_id() 是不行的。那问题出在哪里？或者说要怎么解决？

    问题出在，并发请求之间没有互相“通气”，即先执行的请求没有通知后执行的请求会话 id 已经变了，更没有通知变成哪个新的 id 了。说到这里解决方案
    也就出来了。我们要做到更换会话 id 的同时告诉后续并发请求，会话 id 已经变了，而且要告知它们变成了哪个新的 id。因为后续并发请求会去读取旧
    的会话文件，所以我们就要用旧的会话文件告诉后续并发请求这些情况，所以不能删除旧的会话文件。总之，不能删除旧的会话文件，要在其中放置一个状态
    字段（destroyed）告知会话 id 已变，还要在其中放置一个保存着新的会话 id 的字段（new_session_id）。有了新的会话文件，旧的会话文件只是
    一个过度，所以要设置一个作废时间，这一点可以与 destroyed 字段合起来完成。超过了这个作废时间还在用这个旧的会话文件，就很可能是会话攻击或
    不稳定的网络，也要进行相应的处理（具体见下面的示例中的注释）。

    session_regenerate_id() 只能保证不删除旧的会话文件，却不能实现“通气”（不信的话，你可以在示例 2 中试试，应该能明白是怎么回事）。

    如果你理解了上面所说的，现在应该就能看明白示例 1 和示例 2，也能看明白为什么示例 1 会导致会话丢失，而示例二却没问题。

描述
    session_regenerate_id ([ bool $delete_old_session = FALSE ] ) : bool

    session_regenerate_id() 将使用一个新的会话 id 替换当前的会话 id，并且会保持当前会话信息。

    当启用了 session.use_trans_sid 时，输出必须在 session_regenerate_id() 调用之后开始。否则，会使用旧的会话 ID。

    警告
        目前，session_regenerate_id 不能很好地处理不稳定的网络，例如，移动和 WiFi 网络。因此，通过调用 session_regenerate_id，你可
        能会遇到会话丢失。

        你不应该立即销毁旧的会话数据，而应该使用销毁时间戳并控制对旧会话 ID 的访问。否则，对页面的并发访问可能会导致不一致的状态，或者你可能
        会丢失会话，或者它可能会导致客户（浏览器）端竞争条件，并可能不必要地创建许多会话 ID。即时会话数据删除也禁用了会话劫持攻击检测和预防。

参数
    delete_old_session
        是否删除关联的旧的会话文件。如果你需要避免由于删除引发的竞争或检测/避免会话劫持攻击，那么你不应该删除旧的会话。

返回值
    成功时返回 TRUE，失败时返回 FALSE。

更新日志
    版本	    描述
    7.0.0	session_regenerate_id() 在关闭前保存旧的会话数据。
    5.1.0	添加了 delete_old_session 参数。

示例
    这里的示例非常重要，第一个示例确实是不安全的，而且第二个示例确实是对的，需要时直接参考，不要怀疑，特别是怀疑为什么
    my_session_regenerate_id() 中用的是 session_commit()，而不是 session_regenerate_id()。
