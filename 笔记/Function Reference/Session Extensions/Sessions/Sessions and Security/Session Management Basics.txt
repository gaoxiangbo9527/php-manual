会话安全
    会话模块不能保证会话中存储的信息仅由创建该会话的用户查看。取决于与会话相关联的值，需要采取其他措施来保护会话的机密性。

    需要评估会话中携带的数据的重要性，并可能要部署进一步的保护措施；这通常是有代价的，比如降低了用户的便利性。例如，为了保护用户不受一个简单
    的社会工程策略的影响，需要启用 session.use_only_cookie。在这种情况下，在客户端必须无条件地启用 cookie，否则会话将无法工作。

    有几种方法会将现有会话 ID 泄漏给第三方。例如，JavaScript 注入，URL 中的会话 ID，数据包检测，对设备的物理访问，等等。泄漏的会话 ID 允
    许第三方去访问与特定的 ID 关联的所有资源。首先，携带会话 ID 的 URL。如果它们链接到外部站点或者资源，那么包含会话 ID 的 URL 可能会被存
    储在外部站点的 referrer 日志中。第二，更主动的攻击者可能会侦听网络流量。如果未加密，会话 id 将以明文在网络上传递。解决方案是在服务器上
    实现 SSL/TLS，并强制用户使用它。应该使用 HSTS 来提高安全性。

    注意：即使是 HTTPS 也不能一直保护机密数据。例如，CRIME 和 Beast 漏洞可能使攻击者能够读取数据。另外，请注意，许多网络使用 HTTPS MITM
    代理进行审计。攻击者也可能设置这样的代理。

非适应性会话管理
    PHP 的会话管理器目前默认是自适应的。自适应的会话管理器承担了额外的风险。

    从 PHP 5.5.2 开始，session.use_strict_mode 是可用的。当它被启用并且会话保存处理程序支持它时，一个未初始化的会话 ID 会被拒绝并且会
    创建一个新的会话 ID。这可以防止强制用户使用一个已知的会话 ID 的攻击。攻击者可能粘贴链接或发送包含会话 ID 的电子邮件。例如，
    http://example.com/page.php?PHPSESSID=123456789。如果启用了 session.use_trans_sid，受害者将使用攻击者提供的会话 ID 启动会话。
    session.use_strict_mode 可以减少这种风险。

    警告 用户定义的保存处理程序也可以通过实现会话 ID 验证来支持严格的会话模式。所有用户定义的保存处理程序都应该实现会话 ID 验证。

    会话 ID cookie 可以设置 domain，path，httponly，secure 和从 PHP 7.3 开始的 SameSite 属性。浏览器有定义优先级。通过使用优先级，
    攻击者可以设置可以永久使用的会话 ID。使用 session.use_only_cookie 不会解决这个问题。session.use_strict_mode 降低了这种风险。使用
    session.use_strict_mode=On，未初始化的会话 ID 将被拒绝。

    注意：虽然 session.use_strict_mode 降低了自适应会话管理的风险，但攻击者可以强制用户使用由攻击者创建的已初始化的会话 ID。（个人补充：
    攻击者可以去访问网站，在未登录的情况下获取一个有效的会话 ID，然后通过 JavaScript 注入的方式让受害者也使用这个会话 ID，如果受害者没发现
    ，然后进行了登陆，如果你的网站在登陆成功后没有更换会话 ID，那么攻击者就可以通过该会话 ID 得到受害者的身份，然后进行操作。这也说明了，用
    户登陆成功后一定要更换会话 ID，这很重要）例如，JavaScript 注入。本手册的建议可以减轻这种攻击。通过遵循本手册，开发人员应该启用
    session.use_strict_mode，使用基于时间戳的会话管理，并使用 session_regenerate_id() 和推荐的过程重新生成会话 id。如果开发人员遵循
    上面的所有内容，攻击者生成的会话 ID 终究将被删除。当访问一个过时的会话发生时，开发人员应该保存用户的所有活动的会话数据。因为这些信息将与
    后续的调查有关。用户应该被强制退出所有会话，即要求他们重新进行身份验证。这可以防止攻击者滥用偷来的会话。

    警告 访问一个过时的会话并不一定意味着攻击。一个不稳定的网络和/或立即删除活动的会话将导致合法用户使用过时的会话。

    从 PHP 7.1.0 开始，已经添加了 session_create_id()。通过在会话 ID 前面加上用户 ID 前缀，可以操作此函数来有效地访问用户的所有活动的
    会话。在这个设置中，启用 session.use_strict_mode 非常重要。否则，恶意用户可以为其他用户设置恶意的会话 ID。

    注意：PHP 7.1.0 之前的用户应该使用 CSPRNG，例如 /dev/urandom，或者 random_bytes() 和散列函数来生成新的会话 ID。
    session_create_id() 具有冲突检测并根据会话的 INI 设置生成会话 ID。推荐使用 session_create_id()。

会话 ID 重新生成
    session.use_strict_mode 是一个很好的缓解方法，但还不够。为了会话安全性，开发人员必须同样的使用 session_regenerate_id()。

    会话 ID 重新生成降低了会话 ID 被盗的风险，因此必须定期的调用 session_regenerate_id()。例如，对安全敏感的内容每 15 分钟重新生成会话
    ID。即使在会话 ID 被盗的情况下，合法用户和攻击者的会话也会过期。换句话说，用户或攻击者的访问将生成一个过时的会话访问错误。

    会话 ID 必须在用户特权被提升时重新生成，比如在身份验证之后。在将身份验证信息设置到 $_SESSION 之前，必须调用 session_regenerate_id()
    。(从 PHP 7.0.0 开始，session_regenerate_id() 自动保存当前会话数据，以保存时间戳/等等到当前会话。)确保只有新的会话包含已认证标志。

    开发人员不能依赖 session.gc_maxlifetime 的会话 ID 过期。攻击者可能会定期访问受害者的会话 ID，以防止其过期并继续利用它，包括已认证的
    会话。

    相反，开发人员必须实现基于时间戳的会话数据管理。

    警告 尽管会话管理器可以透明地管理时间戳，但这个特性没有被实现。旧的会话数据仍会被保存，直到 GC。同时，开发人员必须确保自己删除过时的会话
    数据。但是，开发人员不能立即删除活动的会话数据。即绝对不能为活动的会话调用 session_regenerate_id(true); 和 session_destroy() 。
    这听起来可能有点矛盾，但这是一个强制性的要求。

    默认情况下，session_regenerate_id() 不会删除过时的会话。所以可能存在过时的已认证的会话以供使用。开发人员必须防止过时的会话被任何人使
    用。必须使用时间戳禁止他们自己访问过时的会话数据。

    警告
        突然删除活动的会话会产生不期望的副作用。当存在到 web 应用程序的并发连接和/或网络不稳定时，会话可能会消失。

        突然删除活动的会话使潜在的恶意访问是无法检测的。

        开发人员必须在 $_SESSION 中设置一个短期的过期时间（时间戳），并禁止自己访问会话数据，而不是立即删除过时的会话。在
        session_regenerate_id() 之后，开发人员不能立即禁止对旧会话数据的访问。以后一定要禁止。例如，对于稳定的网络，如有线网络，几秒钟后
        ，对于不稳定的网络，如手机或 Wi-Fi，几分钟后。

        如果用户访问一个过时的会话（过期的会话），应该拒绝对它的访问。还建议从用户的所有会话中删除身份验证状态，因为它可能代表攻击。

    如果攻击者设置了不可删除的 cookie，那么使用 session.use_only_cookies 和 session_regenerate_id() 可能导致个人的拒绝服务问题。在
    这种情况下，开发人员可以邀请用户删除 cookie，并告知他们可能受到了一个安全问题的影响。攻击者可能通过易受攻击的 web 应用程序、暴露的/恶意
    的浏览器插件、物理受损的设备等设置恶意 cookie。

    警告
        不要误解 DoS 的风险。对于一般的会话 ID 安全性，use_strict_mode=On 是必需的！建议所有站点启用 use_strict_mode。只有当账户受到
        攻击时，DoS 才会发生。应用程序中的 JavaScript 注入漏洞是最常见的原因。

会话数据删除
    过时的会话数据必须不可访问并删除。当前会话模块不能很好地处理这个问题。

    应该尽快删除过时的会话数据。但是，活动的会话不能立即删除。为了满足这些需求，开发人员必须自己实现基于时间戳的会话数据管理。

    在 $_SESSION 中设置和管理过期时间戳。禁止访问过期的会话数据。当检测到访问过时的会话数据时，建议从用户的会话中删除所有身份验证状态，并强
    制它们重新进行身份验证。访问过时的会话数据可能是一种攻击。为了实现这一点，开发人员必须跟踪每个用户的所有活动的会话。

    注意：由于网络不稳定和/或对 web 站点的并发访问，也可能导致对过时会话的访问。例如，服务器试图通过 cookie 设置一个新的会话 ID，但是由于
    连接丢失，Set-Cookie 包可能没有到达客户端。一个连接可以通过 session_regenerate_id() 发出新的会话 ID，但是另一个并发连接可能还没有
    收到新的会话 ID。因此，开发人员必须在以后禁止访问过时的会话。即，基于时间戳的会话管理是必须的。

    总之，不能使用 session_regenerate_id() 或 session_destroy() 销毁会话数据，而必须使用时间戳来控制对会话数据的访问。让
    session_gc() 从会话数据存储中删除过时的数据。

会话和锁定
    默认情况下会话数据是被锁定的以避免竞争条件。为了在请求之间保持会话数据的一致性，锁定是必需的。然而，会话锁定可能被攻击者滥用来执行 DoS
    攻击（个人补充：攻击者得到了某个用户的会话 ID，然后用该会话 ID 发起请求，在攻击者请求期间，合法用户就没办法再使用自己的会话了，看起来就
    是拒绝服务了）。为了减少会话锁定所造成的 DoS 攻击的风险，请尽量减少锁定。当会话数据不需要更新时，可以使用只读会话。在 session_start()
    中使用 'read_and_close' 选项：session_start(['read_and_close' = > 1]); 。在更新 $_SESSION 后，尽快使用 session_commit()
    关闭会话。

    当会话处于非活动状态时，当前会话模块不会检测对 $_SESSION 的任何修改。当会话处于非活动状态时，不修改 $_SESSION 是开发人员的责任。

活动的会话
    开发人员应该跟踪每个用户的所有活动的会话。通知他们有多少活动的会话，来自哪个 IP（和区域），活动了多长时间，等等。PHP 不跟踪这些。开发人
    员应该这样做。

    有各种方法可以实现这一点。一种可能的实现是建立一个数据库来跟踪所需的数据并存储任何相关的信息。由于会话数据是会被 GC 的，开发人员必须关注
    被 GC 的数据以维护活动会话的数据库的一致性。

    最简单的实现之一是“用户 ID 为前缀的会话 ID”，并将所需信息存储在 $_SESSION 中。许多数据库在选择字符串前缀方面具有良好的性能。为此，开发
    人员可以使用 session_regenerate_id() 和 session_create_id()。

    警告 永远不要使用机密数据作为前缀。如果用户 ID 是机密的，可以考虑使用 hash_hmac()。

    警告 在此设置中，启用 use_strict_mode 是强制性的。确保它是启用的。否则，活动的会话的数据库可能被破坏。

    基于时间戳的会话管理对于检测对过时会话的访问是强制性的。当检测到对过时会话的访问时，应该从用户的所有活动会话中删除身份验证标志。这可以防
    止攻击者继续利用偷来的会话。

会话和自动登陆
    开发人员一定不能使用长寿命的会话 id 用于自动登录，因为这会增加会话被盗的风险。应该由开发人员实现自动登录特性。

    为 setcookie() 使用一个安全的一次性的散列键作为自动登录键。使用一个比 SHA-2 更强壮的安全的散列。例如，SHA-256 或更大，随机数据来自
    random_bytes() 或 /dev/urandom。

    如果用户是未认证的，请检查一次性的自动登录键是否有效。在它有效的情况下，对用户进行认证并设置一个新的安全的一次性散列键。自动登录键只能使
    用一次，即永远不要重用自动登录键，总是生成一个新的。

    自动登录键是一个长寿命的身份验证键，应该尽可能地保护它。使用 path/httponly/secure/SameSite cookie 属性来保护它。除非需要，否则永远
    不要传送自动登陆键。

    开发人员必须实现禁用自动登录和删除不必要的自动登录键 cookie 的特性。

CSRF（Cross-Site Request Forgeries）攻击
    会话和身份验证不能防止 CSRF 攻击。开发人员必须自己实现 CSRF 保护。

    output_add_rewrite_var() 可用于 CSRF 保护。有关更多细节，请参阅该手册页。

    注意：7.2.0 之前的 PHP 和 trans sid 使用相同的输出缓冲和 INI 设置。因此，不建议在版本 7.2.0 之前的 PHP 中使用
    output_add_rewrite_var()。

    大多数 web 应用程序框架支持 CSRF 保护。有关更多细节，请参考 web 应用程序框架的手册。

    从 PHP 7.3.0 开始，可以为会话 cookie 设置 SameSite 属性。这是另外一种可以减轻 CSRF 漏洞的措施。
