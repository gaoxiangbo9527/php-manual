现在你已经通过 PDO 连接上了，你必须在开始发起查询之前先理解 PDO 是如何管理事务的。如果你以前从未遇到过事务，它们提供了 4 个主要特性：原子性
、一致性、隔离性和持久性。通俗的说，在一个事务中执行的任何工作，即使是分阶段执行的，也保证在提交时安全地应用到数据库，并且不会受到其他连接的干
扰。事务性工作也可以根据你的请求自动的撤消（前提是你没有已经提交它），这使得你的脚本中的错误处理更加容易。

事务通常是通过“保存”要一次性应用的一批更改来实现的；这有一个很好的副作用，那就是大大提高了这些更新的效率。换句话说，事务可以使你的脚本更快，并
且可能更健壮（你仍然需要正确地使用它们去获得该好处）。

不幸的是，不是每一个数据库都支持事务，所以当你首次打开一个连接时，PDO 需要在所谓的“自动提交”模式下运行。自动提交模式意味着：如果数据库支持隐
式事务的话，那么每一个你运行的查询都有它自己的隐式事务；或如果数据库不支持事务，那么就没有事务。如果你需要一个事务，你必须使用
PDO::beginTransaction() 方法去发起一个。如果底层的驱动不支持事务，将会抛出一个 PDOException 异常（不管你的错误处理设置如何：这总是一个
严重的错误情况）。一旦你在一个事务中，你可以使用 PDO::commit() 或 PDO::rollBack() 去完成它，取决于你在事务期间运行的代码是否成功。

警告 PDO 只会在驱动器级别上检查事务能力。如果某些运行时条件意味着事务不可用，但只要数据库服务器接受启动事务的请求，PDO::beginTransaction()
仍然会返回 TRUE 而不会报错。这种情况的一个例子是在 MySQL 数据库上的 MyISAM 表上使用事务。

当脚本结束时或者当一个连接即将关闭时，如果你有一个未完成的事务，PDO 将自动的回滚它。这是一种在脚本意外终止的情况下帮助避免不一致性的安全措施。
———— 如果你没有显式的提交该事务，那么它就会假设一些事情出了问题，因此为了数据的安全会去执行回滚。

警告 自动回滚只会发生在当是你通过 PDO::beginTransaction() 启动事务的情况下。如果你手动发起一个会启动事务的查询，那么 PDO 无法感知该事务
，因此如果一些不好的事情发生时也不会回滚该事务。
