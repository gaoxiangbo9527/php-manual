下方列出了当前可能的 PCRE 修饰符。圆括号中的名字指的是这些修饰符内部的 PCRE 名称。修饰符中的空格和换行会被忽略，其他字符会引发错误。

i (PCRE_CASELESS)
    如果设置了这个修饰符，模式中的字母会匹配大写和小写字母。

m (PCRE_MULTILINE)
    默认情况下，PCRE 会将主题字符串视为由字符组成的单一“行”（即使它实际上包含一些换行符）。“行开头”元字符（^）只会在字符串的开头匹配，而
    “行结束”元字符（$）只会在字符串的结束匹配，或在一个终止的换行符前匹配（除非设置了 D 修饰符）。这与 Perl 相同。当设置了这个修饰符时，
    “行开始”和“行结束”结构会分别匹配主题字符串中任何换行符的后面或前面，以及在最开始和最末尾的时候。这等同于 Perl 的 /m 修饰符。如果在主题
    字符串中没有 "\n" 字符，或者在模式中没有出现 ^ 或 $，设置这个修饰符没有效果。

s (PCRE_DOTALL)
    如果设置了这个修饰符，模式中的点号元字符会匹配所有的字符，包括换行符。没有它，换行符会被排除在外。这个修饰符等同于 Perl 的 /s 修饰符。
    一个像 [^a] 的否定类总是会匹配一个换行符，不管这个修饰符设置为何。

x (PCRE_EXTENDED)
    如果设置了这个修饰符，模式中的空白数据字符会被完全忽略，除了被转义的或者位于一个字符类中的，并且位于字符类外的未转义的井号（#）和下一个换
    行符之间的所有字符，包括首尾，也会被忽略。这等同于 Perl 的 /x 修饰符，并且使得在复杂的模式中包含注释成为可能。然而，注意这个修饰符只会应
    用于数据字符。空白字符可能永远不会出现在模式中的特殊字符序列中，例如在引入了一个条件子模式的序列 (?( 中。

e (PREG_REPLACE_EVAL)
    警告 这个特性在 PHP 5.5.0 中被废弃，并且从 PHP 7.0.0 开始被移除了。

    个人补充：如上所属，这个修饰符的剩余内容就不翻译了。

A (PCRE_ANCHORED)
    如果设置了这个修饰符，模式会被强制为“锚定”的，即，它会被约束从而只在要被搜索的字符串（主题字符串）的开头进行匹配。这种效果也可以通过模式
    本身中的适当构造来实现，这也是在 Perl 中实现这种效果的唯一方式。

D (PCRE_DOLLAR_ENDONLY)
    如果设置了这个修饰符，模式中的美元符号元字符只会匹配主题字符串的结束。没有这个修饰符，美元符号也会匹配最后一个字符的前面，如果该字符是一个
    换行符的话，但不会匹配任何其他的换行符。如果设置了 m 修饰符，这个修饰符会被忽略。在 Perl 中没有这个修饰符的等价物。

S
    当一个模式将要被使用多次时，为了加快匹配所花费的时间，花更多的时间来分析它是值得的。如果设置了这个修饰符，那么就会执行额外的分析。目前，
    研究一个模式只对没有一个固定起始字符的非锚定模式有用。个人补充：“没有一个固定起始字符的非锚定模式”应该是指像 [a-z]\d+ 这样的模式。

U (PCRE_UNGREEDY)
    这个修饰符颠倒了量词的“贪婪”，这样它们默认就不贪婪了，但如果紧随着 ?，就会变得贪婪。它与 Perl 不兼容。也可以在模式内通过一个 (?U) 修饰
    符设置或通过在量词后面的问号（例如，.*?） 来设置。

    注意：通常，在非贪婪模式下，通常不可能匹配超过 pcre.backtrack_limit 个字符。

X (PCRE_EXTRA)
    这个修饰符开启了与 Perl 不兼容的 PCRE 附加功能。在一个模式中，任何跟着一个没有特殊含义字母的反斜杠会引发一个错误，从而保留这些组合以备
    将来扩展。默认情况下，如 Perl 中一样，一个反斜杠后面跟一个没有特殊意义的字母会被当作一个字面字符对待。目前这个修饰符没有控制其他的特性。

J (PCRE_INFO_JCHANGED)
    (?J) 内部选项设置更改了局部的 PCRE_DUPNAMES 选项。允许子模式的名称重复。从 PHP 7.2.0 开始，也支持 J 作为一个修饰符。

u (PCRE_UTF8)
    这个修饰符开启了与 Perl 不兼容的 PCRE 附加功能。模式和主题字符串会按 UTF-8 对待。一个无效的主题将导致 preg_* 函数不匹配任何内容；一个
    无效的模式将触发 E_WARNING 级别的错误。从 PHP 5.3.4 开始（resp. PCRE 7.3 2007-08-28），5 和 6 个八位字节 UTF-8 序列被认为是无效
    的，之前这些都被认为是有效的 UTF-8。
