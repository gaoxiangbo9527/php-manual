通过最大化和最小化重复，如果后跟的内容匹配失败，通常会导致对该重复项的重新计算，以确定一个不同的重复次数是否能让模式的其余部分匹配。有时，阻止
这种行为是有用的，要么改变匹配的性质，要么在模式创建者知道进行下去没有意义的情况下提前导致它失败。

例如，考虑应用到主题行 123456bar 时的 \d+foo 模式。

在匹配了全部的 6 个数字后，但匹配 "foo" 却失败了，匹配器的正常操作是，在最终失败之前，先尝试只匹配 5 位 \d+ 项，然后再尝试 4 位，依此类推。
一次性子模式提供了这样一种做法，指定一旦模式的一部分匹配了，就不会以这种方式重新计算，因此匹配器会在第一次匹配 "foo" 失败后立即放弃。记法是另
外一种特殊的圆括号，以 (?> 开头，如这个例子：(?>\d+)bar 。
个人补充：(?>\d+)bar 和 \d++bar 的效果应该是一样的。

This kind of parenthesis "locks up" the part of the pattern it contains once it has matched, and a failure further into
the pattern is prevented from backtracking into it. Backtracking past it to previous items, however, works as normal.
个人补充：上面这段英文本身晦涩难懂，花了很久都没找到一种合适的翻译，就不翻译了。个人感觉，就算翻译出来了，实际帮助也不大。

另一种描述是，这种类型的一个子模式会匹配相同的一个独立模式所匹配的字符串，如果锚定在主题字符串中的当前点。

一次性子模式不是捕获子模式。像上面例子那样的简单情况，可以被认为是一种最大化的重复，它必须吞下它所能吞下的一切。因此，尽管 \d+ 和
\d+?（这是重复的一种用法，见 Repetition 章节）都能够调整要匹配的数字的个数以便使模式的其他部分匹配，但 (?>\d+) 却仅能匹配整个数字序列。
（个人补充：这段写的也不怎样，第一句和第二句表达的主题都不一样，我都怀疑第二句是不是放错地方了）

这种结构当然可以包含任意复杂的子模式，并且它可以被嵌套。

一次性子模式可以和向后查找断言一起配合使用以在主题字符串的末尾指定高效的匹配。想象一下这种情况，把一个像 abcd$ 这样的简单模式应用到一个它不能
匹配的长字符串上。因为匹配过程是从做到右进行的，PCRE 将在主题中查找 "a" ，然后查看后面的内容是否会匹配模式的剩余部分。如果模式被指定为
^.*abcd$，那么开头的 .* 会先匹配整个字符串，但当这么做失败后（因为后面没有 "a" 了），它会回溯以匹配除最后一个字符外的全部字符，接下来是除最
后两个字符外的全部字符，依此类推。对 "a" 的搜索再一次覆盖了整个字符串，从右到左，所以我们并没有得到更好的结果。然而，如果该模式被写为
 ^(?>.*)(?<=abcd)，就不会为 .* 项目进行回溯；它只能匹配整个字符串。后面的向后查找断言对最后四个字符执行一次测试。如果这个测试失败，该匹配
会立即失败。对于长字符串，这种方法会在处理时间上有着显著的差异。

当一个模式在子模式中包含无限重复，而子模式本身也可以无限次重复时，使用一次性子模式是去避免某些失败的匹配花费很长时间的唯一方法。模式
(\D+|<\d+>)*[!?] 匹配一个无限数量的子字符串，它要么由非数字组成，要么由包含在 <> 中的数字组成，然后后面跟着 ! 或 ?。如果该模式会匹配，它
会运行的很快。然而，如果该模式被用于 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 的话，它会在花费很长时间后才报告匹配失败了。
这是因为该字符串可以通过很多方式在两种重复之间划分，并且所有可能的方式都需要进行尝试。（例子在末尾使用了 [!?] 而不是单个字符，是因为 PCRE 和
Perl 都进行了优化，当使用单个字符时，会快速失败。它们会记住匹配所需的最后一个字符，如果字符串中没有出现该字符，则会提前失败。）如果模式被修改
为 ((?>\D+)|<\d+>)*[!?]，非数字序列不能被打断，失败发生得很快。
