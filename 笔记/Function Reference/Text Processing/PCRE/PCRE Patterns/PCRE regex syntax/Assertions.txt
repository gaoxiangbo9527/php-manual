断言是对当前匹配点之后或之前的字符的测试，它实际上不消耗任何字符。编码为 \b、\B、\A、\Z、\z、^ 和 $ 的简单断言已经在 转义序列 中描述。更复
杂的断言被编码为子模式。它们有两类：一种是在主题字符串当前位置之前查找的，另一种是在当前位置之后查找的。

断言子模式是以常规的方式进行匹配的，但它不会引发当前匹配位置的变动。向前查找的断言以 (?= 表示肯定的断言并且以 (?! 表示否定的断言。例如，
\w+(?=;) 会匹配跟着一个分号的单词，但分号不会被包含进匹配结果中，而 foo(?!bar) 会匹配任何没有发生后面跟着 "bar" 的 "foo"。注意，看起来类
似的模式 (?!foo)bar 不是去查找 “前面不是 "foo" 的 "bar"”的，而会找到任何 "bar" 的出现，因为当后面三个字符是 "bar "时，断言 (?!foo) 总
是真。需要一个向后查找的断言来实现此效果。

向后查找断言以 (?<= 表示肯定的断言并且以 (?<！表示否定的断言。例如，(?<!foo)bar 确实可以找到前面不是 "foo" 的 "bar"。向后查找断言的内容
是受到限制的，使得它匹配的所有字符串必须具有一个固定的长度。然而，如果有一些替代选择，那么它们并不都必须要具有相同的固定长度。因此
(?<=bullock|donkey) 是被允许的，但 (?<!dogs?|cats?) 会在编译时引发一个错误。只有在向后查找断言最顶层才允许分支匹配不同长度的字符串。与
Perl 5.005 相比，这是一个扩展，Perl 5.005 要求所有分支必须匹配相同长度的字符串。像 (?<=ab(c|de)) 这样的断言是不被允许的，因为它的单个顶
层分支可以匹配两个不同的长度，但如果去使用两个顶层分支：(?<=abc|abde) 它就是可以接受的。向后查找断言的实现方式是，对于每个替代选择，临时将当
前位置向后移动固定的宽度然后尝试进行匹配。如果在当前位置之前没有足够的字符，匹配将被视为失败。向后查找与一次性子模式结合在一起，对于在字符串结
尾的匹配特别有用；在一次性子模式章节的最后给出了一个示例。

一些断言（任何形式的）可以连续的出现。例如，(?<=\d{3})(?<!999)foo 会匹配 "foo" 前面有三个数字，但不能是 "999"。注意，这些断言中的每一个
都独立地应用于主题字符串中的同一点。首先检查前面三个字符都是数字，然后检查这三个相同的字符不能是 "999"。这个模式不会匹配 “"foo" 前面有六个字
符，且前三个是数字，后三个不是 "999"”的情况。例如，它不会匹配 "123abcfoo"。会进行那个匹配的模式是 (?<=\d{3}...)(?<!999)foo 。

这次，第一个断言会查看前面六个字符，检查前三个字符是数字，然后第二个断言会检查 foo 前面的三个字符不是 "999"。

断言可以嵌套在任何组合中。例如，(?<=(?<!foo)bar)baz 会匹配 "baz" 前接 "bar"，而反过来 "bar" 不能前接 "foo"，然而
(?<=\d{3}...(?<!999))foo 是另一种会匹配 "foo" 前接三个数字和任意三个不是 "999" 字符的模式。

断言子模式是非捕获的子模式，并且也不能被重复，因为多次去断言同一件事是没有意义的。任何类型的断言如果在其中包含了捕获子模式，那么将对这些子模式
进行计数，以便对整个模式中的捕获子模式进行编号。但是，只会对肯定断言执行子字符串的捕获，因为对否定断言执行子字符串的捕获没有意义。

断言最多有 200 个带圆括号的子模式。
