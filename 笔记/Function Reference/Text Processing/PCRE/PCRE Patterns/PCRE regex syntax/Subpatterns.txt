子模式由圆括号分隔，它可以被嵌套。将模式的一部分标记为子模式可以做两件事：

1. 它局部化了一组替代选择。例如，模式 cat(aract|erpillar|) 会匹配单词 "cat"，"cataract" 或 "caterpillar" 中的一个。没有圆括号，它将
匹配 "cataract"，"erpillar" 或空字符串。

2. 它将子模式设置为一个捕获子模式（如上所述）。当整个模式匹配时，主题字符串中与该子模式相匹配的部分会通过 pcre_exec() 的 ovector 参数传回
给调用者。从左到右（从 1 开始）统计开始的圆括号以获取捕获子模式的编号。

例如，如果字符串 "the red king" 与模式 the ((red|white) (king|queen)) 相匹配，那么被捕获的子字符串是 "red king"，"red" 和 "king"，
并且被编号为 1，2 和 3。

事实上，普通圆括号实现的这两个功能并不总是很有用。经常有需要一个分组子模式时却没有捕获的需求。如果开始的圆括号后面跟着 "?:"，那么该子模式不会
进行任何捕获，并且在计算任何后续捕获子模式的数量时不被计数。例如，如果字符串 "the white queen" 去匹配模式
the ((?:red|white) (king|queen))，被捕获的子字符串是 "white queen" 和 "queen"，并且被编号为 1 和 2。被捕获的子字符串的最大编号是
65535。但是，根据 libpcre 的配置选项，可能不可能编译这么大的模式。

作为一种方便的速记法，如果在一个非捕获子模式的开头需要任何配置选项，选项字母可以出现在 "?" 和 ":" 之间。因此这两个模式

(?i:saturday|sunday)
(?:(?i)saturday|sunday)

完全匹配相同的字符串集合。由于可选的分支是从左到右被尝试的，并且选项不会被重置直到到达子模式的结束，一个分支中的选项设置确实会影响后续的分支，
因此上述模式们会匹配 "SUNDAY" 以及 "Saturday"。

能够使用语法 (?P<name>pattern) 命名一个子模式。然后，该子模式将根据其正常的数字位置和名称在匹配数组中建立索引。PHP 5.2.2 引入了两种替代语
法 (?<name>pattern) 和 (?'name'pattern) 。

有时需要在一个正则表达式中进行多个匹配，但要交替使用子组。通常，每个子组将会被给予它们自己的反向引用编号，即使它们中只有一个可能会匹配。为了解
决这个问题，(?| 语法允许拥有重复的编号。考虑下面这个与字符串 Sunday 匹配的正则表达式：

(?:(Sat)ur|(Sun))day

当反向引用 1 为空时，Sun 会被存储在反向引用 2 中。当匹配在反向引用 1 中产生 Sat 时，反向引用 2 不存在。（个人补充：这说明 (?: 的计数方式
大概是这样的，只要有走到某个分支，哪怕该分支没有匹配，该分支包含的捕获子模式也会被计数，没走到的分支中包含的捕获子模式不会被计数）改变该模式去
使用 (?| 解决了这个问题：

(?|(Sat)ur|(Sun))day

使用这个模式，Sun 或 Sat 将会被存储在反向引用 1 中。（个人补充：这说明 (?| 的计数方式大概是这样的，只有走到某个分支且该分支匹配了，该分支包
含的捕获子模式才会被计数，没走到的分支中包含的捕获子模式不会被计数）
