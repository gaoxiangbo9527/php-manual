考虑匹配圆括号中的字符串的问题，允许无限的嵌套圆括号。如果不使用递归，做到使用一个模式去匹配最多到某个固定的嵌套深度已经是最好了。该模式不可能
去处理一个任意的嵌套深度。Perl 5.6 提供了一个实验性的工具，它允许正则表达式递归（以及其他的东西）。特殊的项 (?R) 被提供给递归这种特殊情况。
这个 PCRE 模式解决了圆括号问题（假设设置了 PCRE_EXTENDED 选项，从而空白会被忽略）：\( ( (?>[^()]+) | (?R) )* \)

首先它会匹配一个开始的圆括号。然后它会匹配任意数量的子字符串，该子字符串可以是一个非圆括号的序列，或者是模式本身的递归匹配（即一个正确的带括号
的子字符串）。最后有一个关闭的圆括号。

这个特定的示例模式包含了嵌套的无限重复，因此在将该模式应用于不匹配的字符串时，使用一次性子模式来匹配非圆括号的字符串非常重要。例如，当把它应用
于 (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa() 时，它会很快的产生“不匹配”。然而，如果没有使用一次性子模式，这个匹配实际
上会运行非常久，因为重复 + 和 * 可以用很多不同的方式来划分该主题，并且在能够报告失败之前，所有的可能性都必须被先测试。

为任何捕获子模式设置的值都来自设置子模式值的递归的最外层。如果拿上面的模式去匹配 (ab(cd)ef)，捕获圆括号的值是 "ef"，它是在最顶层上接受到的
最后一个值。如果添加了额外的圆括号，给出 \( ( ( (?>[^()]+) | (?R) )* ) \)，那么它捕获的字符串是 "ab(cd)ef"，最顶层圆括号对的内容。如果
在一个模式中有超过 15 个的捕获括号对，在递归过程中，PCRE 必须获得额外的内存来存储数据，这是通过使用 pcre_malloc 完成的，然后通过
pcre_free 释放它。如果不能获得内存，那么它只会保存前 15 个捕获括号对的数据，因为在递归中无法给出内存不足的错误。

(?1)，(?2) 等也可以被用于递归子模式。也可以使用命名子模式：(?P>name) 或 (?&name) 。

如果递归子模式引用（按编号或按名称）的语法在其引用的圆括号之外使用，则其操作方式类似于编程语言中的子例程。一个更早的示例指出，模式
(sens|respons)e and \1ibility 会匹配 "sense and sensibility" 和 "response and responsibility"，但不会匹配
"sense and responsibility"。但如果使用模式 (sens|respons)e and (?1)ibility，它却会匹配 "sense and responsibility" 和另外两个字
符串。但是，这些引用必须遵循它们所引用的子模式。

主题字符串的最大长度是整型变量可以容纳的最大正数。然而，PCRE 使用递归来处理子模式和不确定的重复。这意味着可用的栈空间可能会限制可以由某些模式
处理的主题字符串的大小。
