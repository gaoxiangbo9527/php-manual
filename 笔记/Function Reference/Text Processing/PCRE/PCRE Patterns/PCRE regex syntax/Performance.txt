在模式中出现的某些项比其他项更有效。使用像 [aeiou] 这样的字符类比使用一个替代选择更有效，例如 (a|e|i|o|u)。一般情况下，提供所需行为的最简
单构造通常是最有效的。Jeffrey Friedl 的书中包含了很多关于优化正则表达式以提高性能的讨论。

当一个模式以 .* 开头并且设置了 PCRE_DOTALL 时该模式会隐式的被 PCRE 锚定，因为它只能匹配主题字符串的开头。然而，如果没有设置 PCRE_DOTALL，
PCRE 不能进行这项优化，因为 . 元字符此时不能匹配换行符，并且如果该主题字符串包含有换行符，该模式可以从紧跟在一个换行符后的字符处开始匹配，而
不是从最开始就匹配。例如，模式 (.*) second 会匹配主题 "first\nand second"（其中 \n 代表一个换行符），并且第一个被捕获的子字符串为
"and"。 为了完成这次匹配，PCRE 必须在主题中的每个换行符后重新尝试匹配。

如果正在对不包含换行符的主题字符串使用这样的一个模式，通过设置 PCRE_DOTALL 或者让模式以 ^.* 开头以指定显式的锚定，可以获得最佳的性能。这样
就节省了 PCRE 扫描主题寻找换行符以重新开始的时间。

注意那些包含嵌套不确定重复的模式。当应用于一个不会匹配的字符串时，这样的模式可能会花费很长的时间。考虑模式片段 (a+)*

这个模式能以 33 中不同的方式匹配 "aaaa"，并且随着字符串变得更长，这个数字会迅速的增加。（* 重复可以匹配 0、1、2、3 或 4 次，对于除 0 之外
的每一种情况，+ 重复可以匹配不同的次数。）当模式的剩余部分导致整个匹配都将失败时，PCRE 原则上会尝试所有可能的变化，这可能会花费非常长的时间。

一种优化会捕获了一些更简单的情况，比如 (a+)*b，它后面跟着一个字面字符。在开始进行标准的匹配过程之前，PCRE 会检查主题字符串后面是否有一个
"b"，并且如果没有，它就会立即匹配失败。然而，当没有后跟的字面字符时，这项优化就不能被使用。你可以通过比较 (a+)*\d 和上面的模式的行为来看出区
别。前一种方法应用于一整行 "a" 字符时，几乎会立即失败，而对于一个长度超过 20 个字符的字符串，后者则需要相当长的时间。
