重复是由量词指定的，量词可以跟在下列任何项的后面：

单个字符，可能被转义
. 元字符
字符类
反向引用（见下一节）
带括号的子模式

常规的重复量词指定了允许匹配的最小和最大数目，通过在花括号中给定两个数字，由一个逗号分隔。数字必须小于 65535，并且第一个数字必须小于或等于第
二个数字。例如：z{2,4} 会匹配 "zz"，"zzz" 或 "zzzz"。关闭花括号自身不是一个特殊的字符。如果第二个参数被省略，逗号是存在的，那么就没有（匹
配数量）上限；如果第二个数字和逗号都被省略，量词指定了需要匹配的精确次数。因此 [aeiou]{3,} 会匹配至少 3 个连续的元音，但可以匹配更多，而
\d{8} 会精确匹配 8 个数字。出现在量词不允许的位置的左花括号，或与量词的语法不匹配的左花括号，被当作字面字符。例如，{,6} 不是一个量词，而是
一个四字符的字面字符串。

量词 {0} 是被允许的，这导致该表达式的行为如同前面的项和该量词不存在一样。

为了方便（和历史兼容性），三种最常见的量词拥有单字符的缩写：

单字符量词
    *	相当于 {0,}
    +	相当于 {1,}
    ?	相当于 {0,1}

可以通过在一个不匹配任何字符的子模式后面紧跟一个没有上限的量词来构造一个无限循环，比如：(a?)*

对于这样的模式，早期版本的 Perl 和 PCRE 常常在编译时给出一个错误。然而，因为在某些情况下这是有用的，所以现在这样的模式是被接受的，但是如果子
模式的任何重复实际上不匹配任何字符，循环就会被强制中断。

默认情况下，量词是“贪婪的”，即，它们会尽可能的匹配（一直到所允许的最大次数），当然前提是不会导致模式的其余部分失败。这种行为带来的问题的典型案
例是试图匹配 C 程序中的注释。它们出现在序列 /* 和 */ 之间，并且在该序列中可能会出现单个的 * 和 / 字符。尝试对字符串
/* first comment */ not comment /* second comment */ 应用模式 /\*.*\*/ 以匹配 C 注释会失败，因为它会匹配整个字符串，由于 .* 项目
的贪婪性。

然而，如果一个量词跟着一个问号，那么该量词将会变得懒惰，并且相反的会匹配最小可能的次数，因此模式 /\*.*?\*/ 会对该 C 注释做正确的处理。各种量
词的含义不会发生改变，而只会改变首选的匹配数量。不要把问号的这种用法和它本身用作量词的用法相混淆。因为问号有两种用法，所以有时它可以出现两次，
正如在 \d??\d 中，它会偏好于匹配一个数字，但是可以匹配两个，如果这是该模式会匹配剩余部分的唯一方式的话。

如果设置了 PCRE_UNGREEDY 选项（该选项在 Perl 中不可用），那么这些量词默认是不贪婪的，但通过在它们后面跟上一个问号，个别量词可以变得贪婪。
换句话说，问号会颠倒默认的行为。

量词后跟 + 是“占有欲强的”。它们会吃掉尽可能多的字符并且不会回头以匹配模式的剩余部分。因此，.*abc 会匹配 "aabc"，但 .*+abc 却不会，因为
.*+ 会吃掉整个字符串。占有欲强的量词可用于加快处理速度。

当用一个大于 1 的最小重复计数或有限制的最大重复计数对圆括号子模式进行量化时，编译后的模式需要更多存储空间，与最小或最大数量的大小成比例。

如果一个模式以 .* 或 .{0,} 开始并且设置了 PCRE_DOTALL 选项（相当于 Perl 的 /s），即允许 . 去匹配换行符，那么该模式是隐式锚定的，因为接下
来的任何内容将针对主题字符串中的每个字符位置进行尝试，因此，在第一次匹配之后的任何位置重新尝试整体匹配都是毫无意义的。PCRE 对待这样的模式，就
好像它以一个 \A 开头一样。在已知主题字符串不包含换行符的情况下，当模式以 .* 开头时，为了得到这个优化，设置 PCRE_DOTALL 是值得的，或者使用
^ 来显式地指明锚定。

当一个捕获子模式被重复时，所捕获的值是匹配最终迭代的子字符串。例如，在 (tweedle[dume]{3}\s*)+ 匹配了 "tweedledum tweedledee" 之后，被
捕获的子字符串的值是 "tweedledee"。然而，如果有嵌套的捕获子模式，相应的捕获值可能已经在之前的迭代中设置过。例如，在 /(a|(b))+/ 匹配 "aba"
后，第二个被捕获的子字符的值是 "b"。
