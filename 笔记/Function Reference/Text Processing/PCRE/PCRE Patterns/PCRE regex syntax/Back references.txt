在一个字符类外部，一个反斜杠后跟着一个大于 0 的数字（可能还有更多的数字）是对模式中较早（即，在它的左边）捕获的子模式的反向引用，假设之前已经
捕获了这么多的左圆括号的话。

然而，如果跟在反斜杠后面的十进制数小于 10，它总是会被当作一个反向引用，并且仅当在整个模式中捕获的左圆括号没有那么多时才会引发一个错误。换句话
说，对于小于 10 的数字，被引用的圆括号不需要位于引用的左侧。当涉及到重复并且右侧的子模式已经参与了更早的迭代时，“向前的反向引用”是有意义的。
有关处理反斜杠后面的数字的详细信息，请参阅上面的“反斜杠”部分。

反向引用将匹配当前主题字符串的捕获子模式实际匹配的任何内容，而不是任何与子模式本身匹配的内容。个人补充：即，反向引用引用的是捕获子模式所匹配到
的内容，而不是引用捕获子模式本身，如果要引用捕获子模式本身，直接在模式中再原样写一遍就好了，干嘛还引入什么反向引用。因此模式
(sens|respons)e and \1ibility 会匹配 "sense and sensibility" 和 "response and responsibility"，但不会匹配
"sense and responsibility"。如果在反向引用时强制了大小写敏感（区分大小写）的匹配，那么字母的大小写是相关的。例如，((?i)rah)\s+\1 会匹配
"rah rah" 和 "RAH RAH"，但不会匹配 "RAH rah"，即使原始的捕获子模式自身是大小写不敏感的（不区分大小写）的。

同一子模式可能有多个反向引用。如果在特定的匹配中没有实际使用到某个子模式，那么对它的任何反向引用都将失败。例如，模式 (a|(bc))\2 总是会失败，
如果它开始匹配 "a" 而不是 "bc"。因为可能最多有 99 个反向引用，所以所有跟在反斜杠后面的数字都被作为潜在反向引用编号的一部分。如果模式继续使用
数字字符，则必须使用某个分隔符来终止反向引用。如果设置了 PCRE_EXTENDED 选项，分隔符可以是空白。否则可以使用一个空的注释。


当第一次使用某个子模式时，如果在该子模式的圆括号内出现引用到其自身的反向引用，该反向引用会失败，因此，例如 (a\1) 永远不会匹配。然而，这样的引
用在重复的子模式内部可以非常有用。例如，模式 (a|b\1)+ 会匹配任意数量的 "a" 以及 "aba"，"ababba" 等等。在子模式的每次迭代后，反向引用会匹
配与前一次迭代对应的字符串。为了让这可以工作，该模式必须是这样的一个模式，它的第一次迭代不需要匹配反向引用。可以使用替代分支来实现这个目的，如
上面例子中那样，或者通过一个最小值为 0 的量词来实现（个人补充：应该是指为反向引用指定一个这样的量词，比如 \1* ）。

从 PHP 5.2.2 开始，转义序列 \g 可用于子模式的绝对引用和相对引用。这个转义序列后面必须跟着一个无符号数或负数，可选地被大括号包围。序列 \1、
\g1 和 \g{1} 是同义的。将此模式与无符号数一起使用可以帮助消除在反斜杠后面的使用数字时固有的歧义。这个序列有助于区分反向引用和八进制字符，还
使反向引用后面跟着字面数字变得更容易，例如 \g{2}1。

带负数的 \g 序列的使用表示一个相对引用。例如，(foo)(bar)\g{-1} 将匹配序列 "foobarbar" 并且 (foo)(bar)\g{-2} 将匹配 "foobarfoo"。这
在长模式中非常有用，它是“为了引用前面某个特定的子模式而持续的跟踪子模式的数量”的一种替代方案。

对命名子模式的反向引用可以通过 (?P=name) 实现，或者从 PHP 5.2.2 开始，也可以由 \k<name> 或 \k'name' 实现。另外 PHP 5.2.4 添加了对
\k{name} 和 \g{name} 的支持，并且 PHP 5.2.7 添加了对 \g<name> 和 \g'name' 的支持。
