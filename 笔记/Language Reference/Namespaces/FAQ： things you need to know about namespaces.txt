本 FAQ 分为两节：常见问题和一些有助于完全理解的实现细节。

常见问题
    1. 如果我不使用命名空间，我应该关心这些吗？
        不需要，命名空间不会以任何方式影响任何现有代码，或任何尚未编写的不包含命名空间的代码。
    2. 在一个命名空间中，我怎样才能使用一个内置的或者全局的类？
    3. 我怎样才能在命名空间的类、函数或常量自己的命名空间中使用它们？
    4. 一个类似于 \my\name 或 \name 的名称是如何解析的？
    5. 一个类似于 my\name 的名称是如何解析的？
    6. 一个类似于 name 的非限定的类名是如何解析的？
    7. 一个类似于 name 的非限定的函数名或者常量名是如何解析的？

命名空间实现的几个有助于理解的实现细节
    1. 导入的名字不能与同一文件中定义的类冲突。
        但是可以与被包含的文件中的名称重名，是因为 use 是编译时进行的替换，然后才会去 include 文件，替换时可以先假装 include 不存在。
    2. 不允许嵌套命名空间。
        PHP 不允许嵌套命名空间。
    3. 在 PHP 5.6 以前，函数和常量都不能通过 use 语句被导入。
        PHP 5.6 以前，会被 use 语句影响的元素只有命名空间名和类名。为了缩短一个长的常量或函数，需要导入包含它们的名称空间。
        从 PHP 5.6 起，允许为函数和常量起别名或者导入它们。
    4. 动态的命名空间名（引号引起来的标识符）应该转义反斜线。
        因为反斜线被用作字符串中的转义字符，所以在引号引起来的字符串中总是应当使用双反斜线，否者可能得到意想不到的结果。
        在单引号字符串中，使用反斜杠转义序列要安全得多，但是仍然建议将所有字符串中的反斜线进行转义作为最佳实践。
    5. 使用任何反斜杠引用的未定义常量会出现致命错误。
        类似于 FOO 这样的非限定的未定义常量会产生一个 NOTICE ，说明 PHP 会假设 "FOO" 为该常量的值。
        任何限定的或者全限定的常量，即包含了反斜线的常量，如果没找到的话就会抛出一个致命错误。
    6. 不能覆盖特殊的常量 NULL、TRUE、FALSE、ZEND_THREAD_SAFE 或者 ZEND_DEBUG_BUILD
        如果试图定义一个和特殊的、内置的常量同名的命名空间化常量，则会导致致命的错误。
