在说明这些解析规则之前，这里有一些重要的定义：
    命名空间名称（有关的）定义
    非限定名
        没有命名空间分隔符的标识符，例如 Foo 。
    限定名
        带有命名空间分隔符的标识符，例如 Foo\Bar 。
    全限定名
        带有命名空间分隔符而且以它开头的标识符，例如 \Foo\Bar 。命名空间 \Foo 也是一个全限定名
    相对名
        以 namespace 关键字开头的标识符，例如 namespace\Foo\Bar 。

名称是遵照下面的规则进行解析的：
    1. 全限定名总是解析成不带开头的命名空间分隔符的名字，比如 \A\B 会解析成 A\B 。
    2. 相对名总是解析成使用当前命名空间名替换 namespace 后的名字。如果该相对名出现在全局命名空间中，那么 namespace\ 前缀会被去掉。比如在命名空
    间 X\Y 中的 namespace\A 会解析成 X\Y\A 。相同的名字在全局命名空间中就会被解析成 A 。
    3. 对于限定名，名称的第一段是根据当前类或者命名空间的导入表进行转换的。比如，如果 A\B\C 被导入为 C, 那么名称 C\D\E 会被转换为 A\B\C\D\E 。
    4. 对于限定名，如果没有应用导入规则，那么当前命名空间会放置到该名称的前面。比如再命名空间 A\B 中的名称 C\D\E 会被解析为 A\B\C\D\E 。
    5. 对于非限定名，名称会根据相应的符号类型的导入表进行转换。这意味着类似于类的名称会根据类/命名空间导入表来转换，函数名会根据函数导入表，常量会根
    据常量导入表。
    6. 对于非限定名，如果没有应用导入规则且该名称引用的是一个类似于类的符号，那么当前命名空间会放置到该名称的前面。比如在命名空间 A\B 中的 new C()
    会解析为名称 A\B\C 。
    7. 对于非限定名，如果没有应用导入规则且该名称引用的是一个函数或者常量，同时该代码在全局命名空间之外，那么该名称会在运行时被解析。
    假设代码在命名空间 A\B 中，下面是一个对函数 foo() 的调用是如何解析的：
        在当前的命名空间中查找这个函数：A\B\foo() 。
        尝试查找并调用全局函数 foo() 。
