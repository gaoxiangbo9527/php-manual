本文的标题是“Overloading”，翻译成中文是“重载”，可实际上本文的内容不是编程语言中通常所说的那个“重载”，本文的标题应该使用
“interpreter hooks”，翻译成中文是“解释器钩子”，本笔记中也将使用“解释器钩子”这个词汇。

PHP 的“解释器钩子”提供了动态的创建属性和方法的方法；
这些动态的实体是通过魔术方法进行处理的；
你可以为各种行为类型在一个类中创建对应的魔术方法。

当你在同未定义的或者在当前作用域中不可见的属性或者方法进行交互时，这些“解释器钩子”方法会被调用。

所有的“解释器钩子”方法都必须被定义为 public 。

这些魔术方法的所有参数都不能通过引用传递。

属性的“解释器钩子”
    public void __set(string $name, $mixed $value);
    public mixed __get(string $name);
    public bool __isset(string $name);
    public void __unset(string $name);

    在给不可访问属性赋值时，__set() 会被调用。
    在读取不可访问属性的值时，__get() 会被调用。
    在对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。
    在对不可访问属性调用 unset() 时，__unset() 会被调用。

    参数 $name 是指要操作的变量名称。__set() 方法的 $value 参数指定了 $name 变量的值。

    属性的“解释器钩子”只能在对象上下文中生效，在静态上下文中，不会触发这些魔术方法;
    所以这些魔术方法都不能被声明为 static;
    从 PHP 5.3.0 起，如果将这些魔术方法中的任何一声明为 static 就会报一个警告。

    注意，因为 PHP 处理赋值运算的方式，__set() 的返回值将被忽略。类似的, 在下面这样的链式赋值中，__get() 不会被调用：
    $a = $obj->b = 8;

方法的“解释器钩子”
    public mixed __call(string $name, array $arguments);
    public static mixed __callStatic(string $name, array $arguments);

    在对象上下文中调用一个不可访问方法时，__call() 会被调用。
    在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用。

    $name 参数是要调用的方法的名称。$arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。