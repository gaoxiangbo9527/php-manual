Constructor
    void __construct ([ mixed $args = "" [, $... ]] )

    即使子类定义了构造方法，也不会隐式的调用父类的构造方法；若想调用父类的构造方法，就需要在子类的构造方法中调用 parent::__construct()

    如果子类没有定义构造方法，那么就会继承父类的构造方法，就像普通的类方法一样（前提是父类的构造方法没有被声明为private）

    为了向前兼容PHP 3和4，如果在一个特定的类中找不到__construct()，PHP就会搜索旧式的构造方法，即和类同名的方法；这样就只有一种情况会产生
    兼容性问题，即类中原本就包含了一个__construct()，但却用于表示不同的语义时。

    旧式的构造方法在PHP 7.0中被弃用（DEPRECATED），并且在将来的版本中会被移除，所以在新的代码中应当总是使用__construct()

    和其他方法不同，当__construct()使用和父类的__construct()不同的参数进行覆盖时，PHP 并不会生成一个 E_STRICT 级别的错误

    从 PHP 5.3.3 开始，如果某个方法的名称和某个命名空间下的类名的最后一部分相同，那么该方法不会被当作构造方法对待。

Destructor
    void __destruct ( void )

    一旦没有其他引用在指向某个特定的对象时，析构方法就会被调用；或者在关闭序列中析构方法会以任意的顺序被调用

    和构造方法一样，父类的析构方法也不会被引擎隐式调用。要执行父类的析构方法，必须在子类的析构方法体中显式的调用 parent::__destruct()
    此外也和构造方法一样，子类如果自己没有定义析构方法则会继承父类的构造方法。

    即使使用了exit()停止了脚本的执行，析构方法依然会被执行；在析构方法中调用exit()将会中止剩余的关闭操作的执行

    析构方法在脚本关闭时调用，此时所有的 HTTP 头信息已经发出；脚本关闭时的工作目录有可能和在 SAPI（如 apache）中时不同。

    试图在析构方法（在脚本终止时被调用）中抛出一个异常会导致致命错误
