Constructor
    __construct ([ mixed $args = "" [, $... ]] ) : void

    每当新创建一个对象时，带有构造方法的类都会调用该构造方法。因此构造方法非常适合在对象被使用前进行任何的初始化。

    即使子类定义了构造方法，也不会隐式的调用父类的构造方法；若想调用父类的构造方法，需要在子类的构造方法中调用 parent::__construct()
    如果子类没有定义构造方法，那么就会继承父类的构造方法，就像普通的类方法一样（前提是父类的构造方法没有被声明为private）

    为了向前兼容PHP 3和4，如果在一个特定的类中找不到__construct()，PHP就会搜索旧式的构造方法，即和类同名的方法；这样就只有一种情况会产生
    兼容性问题，即类中原本就包含了一个__construct()，但却用于表示不同的语义时。

    旧式的构造方法在PHP 7.0中被弃用（DEPRECATED），并且在将来的版本中会被移除，所以在新的代码中应当总是使用__construct()

    和其他方法不同，当__construct()使用和父类的__construct()不同的参数进行覆盖时，PHP 并不会生成一个 E_STRICT 级别的错误

    从 PHP 5.3.3 开始，如果某个方法的名称和某个命名空间下的类名的最后一部分相同，那么该方法不会被当作构造方法对待。

Destructor
    __destruct ( void ) : void

    一旦没有其他引用在指向某个特定的对象时，析构方法就会被调用；或者在关闭序列中以任意的顺序调用析构方法。

    和构造方法一样，父类的析构方法也不会被引擎隐式调用。要执行父类的析构方法，必须在子类的析构方法体中显式的调用 parent::__destruct()
    此外也和构造方法一样，子类如果自己没有定义析构方法则会继承父类的析构方法。

    即使使用了exit()停止了脚本的执行，析构方法依然会被执行；在析构方法中调用exit()将会中止剩余的关闭操作的执行。

    在脚本关闭期间调用的析构函数，会在已经发送了HTTP头后调用，脚本关闭阶段的工作目录有可能和在 SAPI（如 apache）中时不同。

    试图在 脚本关闭期间被调用析构方法中 抛出一个异常会导致致命错误。

用户贡献的笔记
    析构方法必须被声明为 public，因为析构方法总是会自动的被在实例外部调用
