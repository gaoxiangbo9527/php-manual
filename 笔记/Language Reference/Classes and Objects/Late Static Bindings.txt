自 PHP 5.3.0 开始，PHP 实现了一个称为延迟静态绑定的特征，它可以用于 在静态继承上下文 中引用 被调用的类。

更准确地说，延迟静态绑定通过存储在最后一个“非转发调用”中命名的类来工作。
在静态方法调用的情况中，它就是显式命名的类(通常是::操作符左边的类)；在非静态方法的调用中，它就是调用对象所属的类。
一个“转发调用”就是由一个 self::、parent:: 或 static:: 静态调用引入的，或者如果在类层次结构中向上，则是由 forward_static_call() 引入。
函数 get_called_class() 可用于获取被调用类名称的字符串并且 static:: 会引入该字符串所表示的作用域。

“延迟绑定”来自这样一个事实: static:: 不会使用定义方法的类来解析，而是使用运行时信息来计算得出。
它也被称为“静态绑定”，因为它可以用于(但不限于)静态方法调用。

self::的限制
    像 self:: 或者 __CLASS__ 这样的到当前类的静态引用会被解析到它们所处的方法所属的类，也就是定义了该方法的类。

延迟静态绑定的使用
    延迟静态绑定试图通过引入一个关键字来解决这个限制（就是 self:: 的限制），该关键字引用最初在运行时调用的类。
    PHP 决定不引入新的关键字，而是使用已经保留的 static 关键字。

    注意
        在非静态上下文中，被调用的类是对象实列所属的类。
        由于 $this-> 是尝试调用相同的作用域中的私有方法，而使用 static:: 可能会得到不同的结果。
        另一个区别是 static:: 只能引用静态属性。

    注意
        延迟静态绑定在遇到一个没有回退的、完全解析的静态调用时会停止（绑定）。
        另一方面，使用诸如 parent:: 或 self:: 等关键字的静态调用将转发调用信息。
