class
    有效的类名
        使用字母或者下划线开头，后面跟着任意数量的字母、下划线和数字，正则表达式表示为：
            ^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$
        不能为PHP保留字
    伪变量$this
        当一个方法从一个对象上下文中调用时（即被一个对象调用时），可以使用伪变量$this
        $this是调用对象的一个引用（通常就是这个方法所属的对象；但也可能是其他的对象，例如当某个方法在另一个对象的上下文中被静态化的调用时）
        静态化的调用非静态方法
            PHP 5.6.0之前
                在一个兼容的上下文中，静态化的调用非静态方法
                    会报 strict
                在一个不兼容的上下文中,静态化的调用非静态方法
                    会报 strict
            PHP 5.6.0 到 PHP 7.0.0
                在一个兼容的上下文中，静态化的调用非静态方法
                    会报 strict
                在一个不兼容的上下文中,静态化的调用非静态方法
                    会报 deprecated
            PHP 7.0.0开始
                在一个兼容的上下文中，静态化的调用非静态方法
                    会报 deprecated
                在一个不兼容的上下文中,静态化的调用非静态方法
                    会报 deprecated

            PHP 7.0.0以后，在一个不兼容的上下文中,静态化的调用非静态方法，$this 为 undefined
new
    除非某个对象定义了一个构造函数且该构造函数在遇到错误时抛出了一个异常，否者 new 总是会创建一个对象
    类应该在实例化之前被定义，并且某些情况下这是必须的
    如果一个包含了某个类名的字符串被提供给 new 使用，那么会创建该类的一个对象；如果该类在某个命名空间中，则必须使用完整的限定名
    如果没有参数需要传递给类的构造函数，则可以省略类名后面的圆括号
    在类的上下文内，可以通过 new self 或者 new parent 来创建一个对象
    对象赋值其实是值传递，但传递的值是对象的地址（引用），所以最终新变量和原变量均指向同一个对象，这种行为和将对象传递给函数时是一样的
    PHP 5.3.0 引入了几种创建对象实例的新方法，如：
        class Test
        {
            static public function getNew()
            {
                return new static;
            }
        }

        class Child extends Test
        {}

        $obj1 = new Test();
        $obj2 = new $obj1;
        var_dump($obj1 !== $obj2);

        $obj3 = Test::getNew();
        var_dump($obj3 instanceof Test);

        $obj4 = Child::getNew();
        var_dump($obj4 instanceof Child);
    PHP 5.4.0 引入了在单个表达式中创建对象并访问其某个成员的能力，如：
        echo (new DateTime())->format('Y');
Properties and methods
    类的属性和方法住在不同的名称空间里，因此类可能会有同名的属性和方法；此时，到底是会访问类的属性，还是调用类的方法，取决于上下文；
    具体来说就是用法到底是一个变量访问还是一个函数调用。
    这也意味着，倘若将一个匿名函数赋值给一个属性，则你无法直接调用这个匿名函数，你必须先将该属性赋值给你一个变量，然后才能够调用该匿名函数；
    但是从PHP 7.0.0 开始，你能够直接调用一个这样的属性了，方式是将这个属性使用圆括号包围起来，具体如下：
    <?php
    class Foo
    {
        public $bar;

        public function __construct() {
            $this->bar = function() {
                return 42;
            };
        }
    }

    $obj = new Foo();

    // as of PHP 5.3.0:
    $func = $obj->bar;
    echo $func(), PHP_EOL;
    // alternatively, as of PHP 7.0.0:
    echo ($obj->bar)(), PHP_EOL;
extends
    一个类只能从一个基类继承，即只能单继承，不能多继承
    继承得到的属性和方法可以被覆盖，方式是使用同父类中定义的名字相同的名字来重新声明它们
    如果一个方法在父类中被定义为final方法，则该方法无法被覆盖
    可以使用parent::引用被覆盖的方法或者静态属性
    覆盖方法时，参数签名必须保持一致，否者PHP会报 E_STRICT 级别的错误；这并不适用于构造方法，构造方法允许覆盖时使用不同的参数。
    (个人补充，覆盖方法时可见性可以不同，应该说可以放宽，但不能收紧)
::class
    （个人补充，首先要注意，它是一个类常量）
    从PHP 5.5.0 开始，class关键字也可以用于类名的解析
    通过使用ClassName::class你就可以得到ClassName这个类的完整限定的类名，这对于具有命名空间的类尤其有用。
    注意
        使用::class的类名解析是 编译时 进行转换的，这意味着当类名字符串被创建时，自动加载还没有发生，因此即使这个类不存在也会展开类名，
        这种情况下是不会报任何错误的。
用户贡献的笔记
    类名是大小写不敏感的，任何大小写形式都可以，但是定义类时的形式被认为是标准形式。
