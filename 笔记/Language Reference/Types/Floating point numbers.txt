形式上：
    LNUM          [0-9]+
    DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
    EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})

    （个人补充）建议只用 e ，而不用 E 。

浮点数的取值范围和平台相关，通常最大值是 1.8e308 并且具有大致 14 位十进制数字的精度（64 位 IEEE 754 格式）。

警告
    浮点数的精度是有限的。
    尽管取决于系统，但 PHP 通常使用 IEEE 754 双精度格式，因此最大的“舍入相对误差”为 1.11e-16 。
    非基本数学运算的误差可能会更大，并且要考虑到进行复合运算时的误差传递。
    永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。

转换为浮点型
    显式转换
        (float) 或 (double) 或 (real)
        floatval()
    隐式转换

    从字符串
        见字符串类型的文档。
    其他类型都先转换为整型，然后在转换为浮点型。
    对象转换为浮点型会产生一个 E_NOTICE 级别的错误，并转换为 1 （个人补充，其实上面的规则包含这条规则）。

比较浮点数
    因为浮点型的内部表示形式，所以直接比较两个浮点数是否相等是有问题的，不过还是有迂回的方法来比较浮点型的数值。
    想要比较浮点数，应该使用“舍入相对误差”的最大值，该值也被称为机器极小值（epsilon）或舍入单位(unit roundoff)，即计算中所能接受的最小的误差值。
    if(abs($a-$b) < $epsilon) {
        echo "true";
    }

NaN
    NaN 表示浮点运算中未定义或者不确定的数值。
    把 NaN 和任何值进行松散或严格的比较，包括 NaN 自身，都会返回 false （NaN 和 TRUE 进行松散比较会返回 true ，进行严格比较会返回 false ）。
    不应该把 NaN 和任何值进行比较，如果要判断一个值是否是 NaN ，应当使用 is_nan() 函数。
    NaN 是一个常量，不区分大小写。
    （个人补充）PSR-2 中提到了 true 、false 和 null 应当使用全小写，但是没有提到 NAN ；个人建议同 true 等保持一致使用全小写形式的 nan ，好处
    就是可以少按 CapsLock 键，虽然使用全大写形式 NAN 的人和示例却非常多。