正式的定义如下：
    LNUM          [0-9]+
    DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
    EXPONENT_DNUM [+-]?(({LNUM} | {DNUM}) [eE][+-]? {LNUM})
个人补充：建议只用 e ，而不用 E 。

浮点数的大小取决于平台，通常最大值约为 1.8e308 并且具有大概 14 位的小数位数精度（64 位 IEEE 754 格式）。
个人补充：IEEE 754 的双精度浮点数的小数位数精度是 15 或者 16 位，为了安全起见一般把 15 位当做小数位数精度，可以使用常量 PHP_FLOAT_DIG
去获取这个位数。

警告
    浮点数的精度
        浮点数的精度是有限的。
        尽管取决于系统，但 PHP 通常使用 IEEE 754 双精度格式，因此最大的“舍入相对误差”为 1.11e-16 。
        非基本数学运算的误差可能会更大，并且要考虑到进行复合运算时的误差传递。
        永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。
    个人补充：这里说的“舍入相对误差”指的应该是常量 PHP_FLOAT_EPSILON 对应的值。

转换为浮点型
    显式转换
        (float) 或 (double) 或 (real)
        floatval() 或 doubleval()
    隐式转换

    从字符串
        见字符串类型的文档。
    其他类型都先转换为整型，然后再转换为浮点型，更多信息请查看 转换为整型。

比较浮点数
    因为浮点型的内部表示形式，所以直接比较两个浮点数是否相等是有问题的，不过还是有迂回的方法来比较浮点型的数值。
    想要比较浮点数，应该使用“舍入相对误差”的最大值，该值也被称为机器极小值（epsilon）或舍入单位(unit roundoff)，即计算中所能接受的最小的
    误差值。
        <?php
            $a = 1.23456789;
            $b = 1.23456780;
            $epsilon = 0.00001;

            if(abs($a-$b) < $epsilon) {
                echo "true";
            }
    个人补充：PHP 7.2.0 引入的 PHP_FLOAT_EPSILON 常量刚好可以用在这种情况中，上面的例子可以改成下面这种：
        <?php
            $a = 1.23456789;
            $b = 1.23456780;

            if(abs($a-$b) < PHP_FLOAT_EPSILON) {
                echo "true";
            }

NaN
    一些数值运算会导致一个值使用常量 NaN 表示。常量 NaN 表示一个浮点运算中未定义或者不确定的数值。
    把 NaN 和任何其它值进行松散或严格的比较，包括 NaN 自身，都会返回 false （NaN 和 TRUE 进行松散比较会返回 true ，进行严格比较会返回
    false ）。
    不应该把 NaN 和任何值进行比较，如果要判断一个值是否是 NaN ，应当使用 is_nan() 函数。
    NaN 是一个常量，不区分大小写。
    个人补充：建议使用全小写形式的 nan ，好处就是可以少按 CapsLock 键，虽然使用全大写形式 NaN 的人和示例却非常多。
