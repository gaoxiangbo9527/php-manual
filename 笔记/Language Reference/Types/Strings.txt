PHP 中每个字符等同于一个字节。
PHP 只支持一个 256 字符的字符集，并不支持原生的 Unicode 字符集。

PHP 7.0.0 以前
    32位
        长度最大为 2GB
    64位
        长度最大为 2GB
PHP 7.0.0 以后
    32位
        长度最大为 2GB
    64位
        长度无限制

语法
    字符串字面量有四种表示法：
        单引号
        双引号
        heredoc
        nowdoc
    单引号
        支持的转义字符只有两个：
            \'  转义为 '
            \\  转义为 \
        其它任何形式的反斜线都会被当成反斜线本身。

        单引号表示法不会解析变量。
    双引号
        支持的转义字符：
            \n
            \r
            \t
            \v
            \e                      >= PHP 5.4.4
            \f
            \$
            \"
            \\
            \[0-7]{1,3}             8进制数值对应的 ascii 字符；表示的数值如果超过256，会截取后8位，返回截取后的数值对应值的 ascii 字符
            \x[0-9a-fA-F]{1,2}      16进制数值对应的 ascii 字符
            \u{[0-9a-fA-F]+}        16进制数值对应的 UTF-8 字符（>= PHP 7.0.0）
        其它任何形式的反斜线都会被当成反斜线本身。

        双引号表示法会解析变量。
    Nowdoc
        不支持任何解析，即没有转义字符，也不会解析变量。

        很适合用于嵌入 PHP 代码或其它大段无需对其中的特殊字符进行转义的文本。

        和 Heredoc 表示法一样使用 <<< 开头，然后紧跟着一个标识符，但是 Nowdoc 的标识符需要用单引号包围，例如：<<<'identifier'
        Heredoc 结构的所有规则也同样适用于 Nowdoc 结构，尤其是结束标识符的规则。

        PHP 5.3.0 开始支持 Nowdoc 。
    Heredoc
        表示法：
            使用 <<< 开头，然后是（开始）标识符，然后是换行符，然后是字符串内容，然后是换行符，然后是（结束）标识符（名字和起始标识符相同），然后
            是一个分号（有时不需要），然后是一个换行符。
            这里说的换行符，是指操作系统所使用的换行符，并不单指 \n 。

        从 PHP 5.3.0 开始，Heredoc 表示法的开始标识符可以使用双引号包围。
        （个人补充）这么做估计是为了和 Nowdoc 相呼应，个人建议 Heredoc 的开始标识符加上双引号。
        标识符的命名规则同其它的 PHP 标签一样：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。

        结束标识符必须是该行的第一列（即结束标识符前必须是一个换行符）。
        结束标识符后可以紧跟一个分号（有时不需要），然后必须是一个换行符。
        如果不遵守上述规则，会导致结束标识不“干净”，PHP 将认为它不是结束标识符而继续向下寻找。
        如果在文件结束前也没有找到一个正确的结束标识符，PHP 将会在最后一行产生一个解析错误。

        Heredoc 支持双引号表示法中除了 \" 以外的所有转义字符串，因为双引号在 Heredoc 中不再需要被转义了。

        Heredoc 支持解析变量。

        从 PHP 5.3.0 开始，可以用 Heredoc 表示法来初始化静态变量和类的属性和常量：但 Heredoc 表示法中不能包含变量解析。
    变量解析
        简单语法
            可以让你在字符串中嵌入变量、(一维)数组元素以及对象属性。
            简单语法只能嵌入这三种数据，其他情况应当使用复杂语法。

            当解析器遇到了一个 $ 符号，它就会去组合尽量多的标识以形成一个合法的变量名（不管变量名是否真实存在）。
            用花括号包围变量名可以指定变量名的结束位置。

            嵌入的数组的索引可以是整数，也可以是字符串，并且字符串索引不能用引号包围（因为实际上花括号就算是定界符了）。
            从 PHP 7.1.0 开始支持负数索引。

            嵌入对象属性的规则同嵌入变量类似，但是不支持花括号定义边界。
        复杂语法（花括号语法）
            被称为复杂语法并不是因为其语法复杂，而是因为它能够让你嵌入复杂的表达式。
            标志性特点就是用花括号包围了表达式。

            只需简单地像在 string 以外的地方那样写出表达式，然后用花括号 { 和 } 把它括起来即可。
            然而 { 无法被转义，只有 $ 紧挨着 { 时才会被识别。可以用 {\$ 来表达 {$。

            支持嵌套函数调用、方法调用、类静态变量和类常量，但求值的结果会当作该字符串所在的命名空间中的某个变量名，而不是直接替换输出。
            仅使用花括号 ({}) 无法处理从函数或方法的返回值或者类常量以及类静态变量的值。
    字符串的存取和字符修改
        可以通过在字符串变量名后，用类似数组结构中的方括号 [] 包含期望字符的基于 0 的下标来访问和修改字符串中的字符。
        也可以使用花括号 {} 来访问或者修改字符串中的字符。

        从 PHP 7.1.0 开始支持负数下标。在这之前，读取时使用负数下标会报 E_NOTICE 级别的错误；写入时使用负数下标会报 E_WARNING 级别的错误。

        警告
            正数下标
                从超出范围的下标中读取内容会抛出 E_NOTICE 级别的错误。
                向超出范围的下标中写入内容会拉长该字符串并且使用空格填充。
            负数下标
                从超出范围的下标中读取内容会抛出 E_NOTICE 级别的错误。
                向超出范围的下标中写入内容会抛出 E_WARNING 级别的错误。

            非整型的下标会转换成整型。
            从 PHP 5.4.0 开始，合法下标类型只有整型以及类整型的字符串，其他类型均算非法下标类型，而非法下标类型会产生一个 E_WARNING 级别或者
            E_NOTICE 级别的错误。
            （个人补充）虽然手册上说只会产生 E_WARNING 级别的错误，但是个人测试时发现有时候产生的是 E_NOTICE 级别的错误。

            如果赋予的字符串的长度大于1，则只会使用该字符串的第一个字符进行赋值。

            从 PHP 7.1.0 开始，当赋予的字符串是一个空字符串时会抛出一个致命错误；在 PHP 7.1.0 之前，这么做会赋值为空字符。

        警告
            因为 PHP 的字符串在内部看是字节组成的数组。因此用花括号访问或修改多字节字符集的字符串很不安全。
            仅应对单字节字符集例如 ISO-8859-1 的字符串进行此类操作。

        注意
            用 [] 或 {} 访问任何其它类型（不包括数组或实现了相应接口的对象）的变量只会无声地返回 NULL 。

        从 PHP 5.5.0 开始支持在一个字符串字面量后使用 [] 或者 {} 来访问其某个字符。
有用的函数和操作符
    . 操作符

    字符串函数
    兼容 Perl 的正则表达式函数
    URL 字符串函数
    加密/解密 的字符串函数
    字符类型函数 ctype_*
转换为字符串
    显式转换
        (string)
        strval()
    隐式转换

    从布尔型
        true    "1"
        false   ""
    从整型
        转换为字面样式
    从浮点型
        转换为字面样式
        使用指数计数法的浮点数也可转换（4.1E+6）。
    从字符串
        不转换
    从数组
        总是转换为字符串 "Array" ，而且会回产生 E_NOTICE 级别的错误。
    从对象
        必须要使用魔术方法 __toString() ，其结果就是转换后的值
        否者会产生致命错误
    从资源
        转换为类似 "Resource id #1" 的字符串，其中 1 是 PHP 在运行时给该资源分配的唯一的编号
        不要依赖这种转换后的字符串的结构，在将来说不定会变化
    从callable
        手册中没提到
    从 NULL
        总是转换为空字符串 ""

字符串转换为数值
    如果该字符串没有包含 '.'，'e' 或 'E' 并且其数字值在整型的范围之内，该字符串将被当成整型来取值。其它所有情况下都被作为浮点型来取值。

    字符串的开始部分决定了它的值。
    如果该字符串以合法的数值开始，则使用该数值；否则其值为 0（零）。
    合法数值由可选的正负号，后面跟着一个或多个数字（可能有小数点），再跟着可选的指数部分。
    指数部分由 'e' 或 'E' 后面跟着一个或多个数字构成。

    不要想像 C 语言那样，通过将一个字符（串）转换为整型就能得到其代码。使用函数 ord() 和 chr() 实现 ASCII 码和字符间的转换。

字符串类型详解
    PHP 中的字符串被实现为一个字节数组以及一个指明该缓冲长度的整数，字符串中并没有信息关于如何将这些字节转化成字符，而把这个任务留给了编程人员。

    字符串由什么值来组成并无限制；特别是值为 0的字节（“NUL bytes”）可以出现在字符串的任何位置。
    （不过有几个函数，在本手册中被称为非“二进制安全”的函数，可能会把 NUL 字节之后的数据全都忽略）

    字符串类型的本质也解释了为何 PHP 中没有字节类型 —— 因为字符串代替了这个角色。

    由于 PHP 并不特别指明字符串的编码，那字符串到底是怎样编码的呢？答案是字符串会被按照该脚本文件相同的编码方式来编码。
    不过这并不适用于激活了 Zend Multibyte 的情况，此时可以用任何编码来编写脚本（明确指定编码或被自动检测）并且该脚本会被转换为某种内部编码，然后
    字符串字面量也会使用该内部编码。
    脚本可使用的编码（如果激活了 Zend Multibyte 则是其内部编码）存在一些限制 —— 该编码应该是 ASCII 的兼容超集，例如 UTF-8 或 ISO-8859-1 。

    要做到有用，操作文本的函数必须假定字符串是如何编码的。不幸的是，PHP 关于此的函数有很多变种：
        某些函数假定字符串是以单字节编码的，但并不需要将字节解释为特定的字符，例如 substr()，strpos()，strlen() 和 strcmp()；
        理解这些函数的另一种方法是它们作用于内存缓冲区，是按照字节和字节下标进行操作的。

        某些函数可以传入字符串的编码方式；如果没有传入则可能会假定一个默认的编码；htmlentities() 和 mbstring 扩展中的大部分函数均属于这种情况。

        某些函数使用了当前区域（见 setlocale()），但逐字节操作。例如 strcasecmp()，strtoupper() 和 ucfirst()。
        这意味着这些函数只能用于单字节编码，而且编码要与区域匹配。

        最后一些函数会假定字符串是使用某特定编码的，通常是 UTF-8。intl 扩展和 PCRE（仅在使用了 u 修饰符时）扩展中的大部分函数都是这样。

    最后，要书写能够正确使用 Unicode 的程序依赖于很小心地避免那些可能会损坏数据的函数。要使用来自于 intl 和 mbstring 扩展的函数。
    不过使用能处理 Unicode 编码的函数只是个开始。不管用何种语言提供的函数，最基本的还是了解 Unicode 规格。
