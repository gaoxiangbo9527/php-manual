用于判断某个类是否能使用foreach进行遍历的接口。
来自用户贡献的笔记，可以解释上面用法：
    if(!is_array($items) && !$items instanceof Traversable)
    （个人补充）这可能是 Traversable 接口唯一真正实用的用途了。

该接口是一个抽象基接口，是不能被直接实现的，而必须要借助 Iterator 或者 IteratorAggregate 才能被间接的实现。

注意
    PHP 的内置类可以直接实现该接口从而被 foreach 遍历，并且不需要借助 Iterator 或者 IteratorAggregate 。

注意
    Traversable 是一个内部引擎接口，所以在 PHP 脚本中不能实现它，相反的必须要借助 Iterator 或者 IteratorAggregate 。
    当实现一个 extends 了 Traversable 接口的接口时，请确保在实现子句中，在它（一般就是某个类名）的前面列出 Iterator 或者 IteratorAggregate 。
    上面的描述用代码表示的话差不多就像下面这样：
        interface Foo extends Traversable {
            public function bar();
        }

        class Baz implements Iterator, Foo {
            public function bar() {
                echo 'function bar';
            }
            ...其他需要实现的方法
        }
    （个人补充）上面的这种用法也没什么实际意义，就不要这么用了，可以的话就用 Iterable 接口。

接口摘要
    Traversable {
    }
    这个接口没有方法，它的唯一目的就是作为所有可遍历类的基接口。



