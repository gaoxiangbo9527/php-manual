持久连接是在脚本结束执行时不会关闭的连接。当请求一个持久连接时，PHP 会检查是否已经存在一个相同的持久连接（先前就保持打开的）——并且如果存在，
PHP 就会使用它。如果不存在，PHP 会创建该连接。“相同”的连接是指使用相同的用户名和密码（如果适用）打开到相同主机的连接。

对 web 服务器工作以及分配负载的方式没有完全了解的人可能会错误地认为持久连接的作用。尤其是，持久连接不能让你在相同的连接上打开“用户会话”，它们
不会给你有效地建立事务的能力，并且它们也不会做很多其他的事情。实际上，可以非常明确地说，持久连接不会提供任何非持久连接无法提供给你的任何功能。

为什么？

这和 web 服务器工作的方式有关。web 服务器可以通过三种方式去利用 PHP 生成 web 页面。

第一种方法是将 PHP 用作一个 CGI “包装器”。当以这种方式运行时，对于到 web 服务器的每一个页面请求（一个 PHP 页面请求）都会有一个 PHP 解析器
的实例被创建和销毁。因为在每个请求之后该 PHP 解析器实例都会被销毁，所以在它被销毁时它所获取到的任何资源（比如一个到 SQL 数据库服务器的连接）
都会被关闭。在这种情况下，尝试使用持久连接不会获得任何好处 —— 它们根本就不持久。
个人补充：就是说这种情况下，就算本次请求创建了一个持久连接并保存起来了，但是最终在本次请求结束时，该持久连接还是会被销毁。当下次请求进来时，尝
试去找该持久连接也是不会找到的。既然这样，索性还不如不用持久连接，而是直接使用非持久连接，也省去了一些麻烦。

第二种也是最流行的方法是将 PHP 用作多进程 web 服务器中的一个模块，目前只适用于 Apache 。多进程服务器通常有一个进程（父进程），它协调一组实
际去完成服务 web 页面工作的进程（子进程）。当从客户端发来一个请求时，该请求会被传递给一个尚未服务于任何客户端的子进程。这意味着当相同的客户端
发起第二个到服务器的请求时，它可能会由与第一次不同的子进程提供服务。当打开一个持久连接后，后续每个会请求 SQL 服务器的页面都可以复用这个已建立
的、到该 SQL 服务器的连接。

最后一种方法是将 PHP 用作多线程 web 服务器的一个插件。目前 PHP 4 已经支持 ISAPI、WSAPI 和 NSAPI（在 Windows 上），这使 PHP 可以被用作
诸如 Netscape FastTrack（iPlanet）、Microsoft's Internet Information Server（IIS）和 O'Reilly's WebSite Pro 等多线程 web 服务
器的插件。此时，持久连接的行为与前面多进程模型中所描述的行为本质上是相同的。

如果持久连接没有任何新增的功能，那它们有什么好处?

答案非常简单 —— 效率。如果创建一个到你的 SQL 服务器的连接的开销很高，持久连接就很好。这项开销是否真的很高取决于许多因素。比如，数据库的类型，
数据库是否与 web 服务器坐落在同一台计算机上，SQL 服务器所在机器的负载情况如何，等等。底线是，如果连接的开销很高，那么持久连接将大大帮助你。
持久连接会让子进程在整个生命周期中只连接一次，而不是在每次处理需要连接到 SQL 服务器的页面时都去连接一次。这意味着，对于每一个已打开持久连接的
子进程，都将拥有它自己到服务器的持久连接。例如，如果有 20 个不同的子进程，且它们都会运行一个持久连接到 SQL 服务器的脚本，那么你就会有 20 个
不同的到 SQL 服务器的连接，每个子进程一个。

但是请注意，如果你使用一个带有连接数限制的数据库，并且持久子连接的数目超过了该限制，那么可能会有一些缺点。如果你的数据库限制最多能有 16 个并
发连接，并且在一个繁忙的服务器会话期间，有 17 个子线程尝试连接，那么有一个子线程将无法连接。此时，如果在你的脚本中有不允许关闭连接的 bug （
比如无限循环），只有 16 个连接的数据库将迅速地受到影响（个人补充：如果脚本中有这种无法关闭连接的 bug，那么所有可用的连接将会被全部占用，新进
来的请求将永远不能连接数据库了，除非该连接被数据库自己的给回收了）。查看你的数据库文档，了解如何处理废弃的或空闲的连接。

警告
    使用持久连接时，要留意一些额外的问题。一个问题是：当在一个持久连接上使用表锁定时，如果脚本不知道因什么原因无法释放该表锁，那么使用同一个
    连接的后续脚本将会无限期阻塞，并且需要你要么去重启 httpd 服务器，要么去重启数据库服务器。另一个问题是：如果脚本在事务块之前结束（个人补
    充：即在脚本结束时没有提交或者回滚事务块），那么该事务块将会延续到使用该连接的下一个脚本。不论是哪种情况，你都能使用
    register_shutdown_function() 注册一个简单的清理函数去解除锁定你的表或者回滚你的事务。更好的方法是，在使用表锁或事务的脚本中不使用持
    久连接，从而完全避免这个问题，你仍然可以在其他地方使用它们（个人补充：现在我们几乎会为每一次请求开启 请求事务 ，所以这几乎可以说是判持久
    连接死刑了）。

一个重要的总结。持久连接被设计成和常规连接一一对应。这意味着你应当总是能使用非持久连接替换持久连接，并且不会改变脚本的行为。它可以（并且很可能
会）改变脚本的效率，但不会改变脚本的行为。

另请参阅 fbsql_pconnect()、ibase_pconnect()、ifx_pconnect()、ingres_pconnect()、msql_pconnect()、mssql_pconnect()、
mysql_pconnect()、ociplogon()、odbc_pconnect()、oci_pconnect()、pfsockopen()、pg_pconnect() 和 sybase_pconnect() 。
