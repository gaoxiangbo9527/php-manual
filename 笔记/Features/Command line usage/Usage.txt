有三种不同的方式可以提供将要被执行的 PHP 代码给 CLI SAPI :
    1. 告诉 PHP 去执行某个特定的文件。
        $ php my_script.php
        $ php -f my_script.php
        两种方法(不管是否使用 -f 开关)都会执行文件 my_script.php 。注意，对于哪种文件可以被执行并没有限制；尤其是文件名不需要有 .php 扩展名。
        注意
            当使用 -f 时，如果有参数需要被传递给脚本，那么第一个参数必须是 -- 。
    2. 传递将要直接在命令行上执行的 PHP 代码。
        $ php -r 'print_r(get_defined_constants());'
        必须特别注意 shell 变量的替换和引号的使用。（个人补充，在 Windows 命令行中，单引号要换成双引号）
        注意
            仔细阅读示例：没有开始和结束标签！-r 开关根本不需要它们，并且使用它们会导致解析错误。
    3. 通过标准输入（stdin）提供将要被执行的 PHP 代码。
        这提供了动态的创建 PHP 代码并将其提供给二进制文件的强大功能，正如这个（虚构的）例子所示：
        $ some_application | some_filter | php | sort -u > final_output.txt
你不能组合这三种方式中的任何一种去执行代码。

与每个 shell 应用程序一样，PHP 二进制程序可以接受一些参数；然而，PHP 脚本还能接收更进一步的参数。PHP 没有限制可以传递给脚本的参数的数量（虽然
shell 对可以传递的字符数有一个限制，但通常不太可能被碰到）。传递给脚本的参数在全局数组 $argv 中可用。第一个索引(0)总是包含从命令行调用的脚本的名称。
注意，如果代码是使用命令行开关 -r 在行内执行的，$argv[0] 的值只会是一个破折号（-）。如果代码是通过来自 STDIN 的管道被执行的，也会如此。
第二个全局变量 $argc ，包含了 $argv 数组中的元素数量（而不是传递给脚本的参数数量）。

只要传递给脚本的参数不是以 - 字符开头，就没有什么需要特别注意的。
向脚本传递一个以 - 开头的参数会引起麻烦，因为 PHP 解释器认为它自身需要处理该参数，而且还是在执行脚本之前。
为了防止这种情况发生，请使用参数列表分隔符 -- 。在这个分隔符被 PHP 解析后，跟在后面的每个参数都会被原原本本地传递给脚本。
（个人补充，上文的内容全都针对提供代码给 php 执行的方式的）

然而，在 Unix 系统中还有一种使用 PHP 编写 shell 脚本的方法：使脚本的第一行以 #!/usr/bin/php （如果你的 PHP CLI 二进制文件的路径不是这个，请
更换成你自己的）开头。文件的剩余部分应该在通常的 PHP 开始和结束标记中包含正常的 PHP 代码。一旦该文件的执行属性设置得当（比如 chmod +x test），该
脚本就能像其他 shell 脚本或者 perl 脚本一样被执行。
可以看出，在这种情况下，在传递以 - 开头的参数时不需要特别注意。

PHP 可执行文件可用于运行完全独立于 web 服务器的 PHP 脚本。
在 Unix 系统中，特殊的 #! （也称 shebang）第一行应当添加到 PHP 脚本，从而系统可以自动判断哪个程序会运行该脚本。
在 Windows 平台上，可以将 php.exe 与 .php 扩展的双击选项相关联，或者可以创建一个批处理文件来通过 PHP 运行脚本。
Unix 特殊的 shebang 第一行对 Windows 没有任何危害（因为它的格式是 PHP 注释）。所以通过包含它就可以编写出跨平台的程序。

另请参阅 Readline 扩展的文档去了解更多可用于增强 PHP 的命令行应用程序的函数。

在 Windows 上，可以配置 PHP，让其不需要提供 C:\php\php.exe 或 .php 扩展名就能运行，如 Microsoft Windows 上的 PHP 命令行 所述。
